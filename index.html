<!DOCTYPE html>
<html lang="uk">

<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>–ú–∞—Ç—Ä–∏—á–Ω–∏–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä: –ü–æ–≤–Ω–∏–π –†–æ–∑–≤'—è–∑–æ–∫</title>
      <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/8801/8801287.png" type="image/x-icon" />
      <style>
            body {
                  font-family: Arial, sans-serif;
                  margin: 20px;
                  background-color: #f4f4f9;
            }

            .container {
                  max-width: 1100px;
                  margin: auto;
                  background: white;
                  padding: 20px;
                  border-radius: 8px;
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            h1 {
                  color: #333;
                  text-align: center;
            }

            .controls-grid {
                  display: grid;
                  grid-template-columns: 1fr 1fr 1fr;
                  gap: 20px;
                  margin-bottom: 15px;
                  align-items: end;
            }

            label {
                  display: block;
                  margin-bottom: 5px;
                  font-weight: bold;
            }

            input[type="number"],
            input[type="text"] {
                  padding: 8px;
                  border: 1px solid #ccc;
                  border-radius: 4px;
                  width: 100%;
                  box-sizing: border-box;
            }

            button {
                  background-color: #007bff;
                  color: white;
                  padding: 10px 15px;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 16px;
                  transition: background-color 0.3s;
                  width: 100%;
            }

            button:hover {
                  background-color: #0056b3;
            }

            #matrixInput {
                  display: grid;
                  gap: 10px;
                  margin-top: 15px;
            }

            .matrix-row {
                  display: flex;
                  gap: 10px;
            }

            .matrix-row input {
                  text-align: center;
                  flex: 1;
            }

            #results {
                  margin-top: 20px;
                  padding: 15px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  background-color: #e9ecef;
                  white-space: pre-wrap;
                  font-family: "Courier New", Courier, monospace;
                  overflow-x: auto;
            }

            .error-message {
                  color: red;
                  font-weight: bold;
            }
      </style>
</head>

<body>
      <div class="container">
            <h1>–ú–∞—Ç—Ä–∏—á–Ω–∏–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä üìä</h1>
            <div class="controls-grid">
                  <div>
                        <label for="rowsSize">–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤ (M):</label>
                        <input type="number" id="rowsSize" min="1" max="10" value="3" onchange="createMatrixInputs()">
                  </div>
                  <div>
                        <label for="colsSize">–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Å—Ç–æ–≤–ø—Ü—ñ–≤ (N):</label>
                        <input type="number" id="colsSize" min="1" max="10" value="3" onchange="createMatrixInputs()">
                  </div>
                  <div>
                        <label for="rankK">–†–∞–Ω–≥ –¥–ª—è –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è (k):</label>
                        <input type="number" id="rankK" min="1" value="2" onchange="updateRankKMax()">
                  </div>
            </div>
            <div>
                  <label>–í–≤–µ–¥—ñ—Ç—å –µ–ª–µ–º–µ–Ω—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ñ A:</label>
                  <div id="matrixInput"></div>
            </div>
            <div id="vectorBContainer" style="margin-top: 15px;">
                  <label>–í–≤–µ–¥—ñ—Ç—å –≤–µ–∫—Ç–æ—Ä b (–¥–ª—è –º–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ):</label>
                  <div id="vectorBInput"></div>
            </div>
            <button onclick="calculate()" style="margin-top: 15px;">–û–±—á–∏—Å–ª–∏—Ç–∏</button>
            <div id="results">–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑'—è–≤–ª—è—Ç—å—Å—è —Ç—É—Ç.</div>
      </div>

      <script>
            // --- –í–•–Ü–î–ù–Ü –î–ê–ù–Ü –ó –ó–ê–í–î–ê–ù–ù–Ø (–ó –ü–ï–†–ï–°–¢–ê–ù–û–í–ö–û–Æ –î–õ–Ø –ó–ë–Ü–ñ–ù–û–°–¢–Ü) ---
            const defaultMatrixValues = [[11, 0.5, -3], [1, 18, -3], [2, 0, 18]];
            const defaultVectorBValues = [-5, -10, -3];
            const EPSILON = 1e-10;

            // --- UI FUNCTIONS ---
            function updateRankKMax() { const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value), rankKInput = document.getElementById('rankK'); if (!isNaN(M) && !isNaN(N)) { rankKInput.max = Math.min(M, N); } }
            function createMatrixInputs() {
                  const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value);
                  const matrixContainer = document.getElementById('matrixInput'), vectorBContainer = document.getElementById('vectorBContainer'), vectorBInput = document.getElementById('vectorBInput');
                  if (M < 1 || M > 10 || isNaN(M) || N < 1 || N > 10 || isNaN(N)) { matrixContainer.innerHTML = `<span class="error-message">–†–æ–∑–º—ñ—Ä –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –≤—ñ–¥ 1 –¥–æ 10.</span>`; vectorBContainer.style.display = 'none'; return; }
                  matrixContainer.innerHTML = '';
                  for (let i = 0; i < M; i++) {
                        const rowDiv = document.createElement('div');
                        rowDiv.className = 'matrix-row';
                        for (let j = 0; j < N; j++) {
                              const input = document.createElement('input');
                              input.type = 'text'; input.id = `m-${i}-${j}`;
                              if (M === 3 && N === 3 && defaultMatrixValues[i]?.[j] !== undefined) input.value = defaultMatrixValues[i][j];
                              else if (M === N) input.value = (i === j) ? '1' : '0';
                              else input.value = '0';
                              rowDiv.appendChild(input);
                        }
                        matrixContainer.appendChild(rowDiv);
                  }
                  if (M === N) {
                        vectorBContainer.style.display = 'block'; vectorBInput.innerHTML = '';
                        const rowDiv = document.createElement('div'); rowDiv.className = 'matrix-row';
                        for (let i = 0; i < M; i++) {
                              const input = document.createElement('input');
                              input.type = 'text'; input.id = `v-${i}`;
                              input.value = (M === 3 && defaultVectorBValues[i] !== undefined) ? defaultVectorBValues[i] : i + 1;
                              rowDiv.appendChild(input);
                        }
                        vectorBInput.appendChild(rowDiv);
                  } else { vectorBContainer.style.display = 'none'; vectorBInput.innerHTML = ''; }
                  updateRankKMax();
            }
            function calculate() {
                  const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value);
                  const matrix = [];
                  for (let i = 0; i < M; i++) {
                        const row = [];
                        for (let j = 0; j < N; j++) {
                              const value = parseFloat(document.getElementById(`m-${i}-${j}`).value.replace(',', '.'));
                              if (isNaN(value)) { document.getElementById('results').innerHTML = `<span class="error-message">–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —É –ø–æ–ª—ñ [${i + 1},${j + 1}].</span>`; return; }
                              row.push(value);
                        }
                        matrix.push(row);
                  }
                  let vectorB = null;
                  if (M === N) {
                        vectorB = [];
                        for (let i = 0; i < M; i++) {
                              const value = parseFloat(document.getElementById(`v-${i}`).value.replace(',', '.'));
                              if (isNaN(value)) { document.getElementById('results').innerHTML = `<span class="error-message">–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —É –≤–µ–∫—Ç–æ—Ä—ñ b, –ø–æ–∑–∏—Ü—ñ—è [${i + 1}].</span>`; return; }
                              vectorB.push(value);
                        }
                  }
                  const result = matrixOperations(matrix, vectorB);
                  displayResults(result);
            }

            // --- LINEAR ALGEBRA HELPERS ---
            function transpose(m) { if (!m || !m.length || !m[0].length) return []; return m[0].map((_, c) => m.map(r => r[c])); }
            function multiply(a, b) { return a.map(row => b[0].map((_, j) => row.reduce((sum, val, k) => sum + val * b[k][j], 0))); }
            function multiplyMatrixVector(A, v) { return A.map(r => r.reduce((s, x, j) => s + x * v[j], 0)); }
            function dot(v1, v2) { return v1.reduce((s, x, i) => s + x * v2[i], 0); }
            function norm(v) { return Math.sqrt(dot(v, v)); }
            function normalize(v) { const n = norm(v); return (n < EPSILON) ? v.map(() => 0) : v.map(x => x / n); }
            function subtractVectors(v1, v2) { return v1.map((x, i) => x - v2[i]); }
            function scalarMultiply(s, v) { return v.map(x => s * x); }
            function outerProduct(u, v) { return u.map(val_u => v.map(val_v => val_u * val_v)); }
            function subtractMatrices(A, B) { return A.map((row, i) => row.map((val, j) => val - B[i][j])); }
            function getNorms(m) { let n1 = 0, ni = 0, nF = 0; if (!m.length) return { n1, ni, nF }; for (let j = 0; j < m[0].length; j++) n1 = Math.max(n1, m.reduce((s, r) => s + Math.abs(r[j]), 0)); for (let i = 0; i < m.length; i++) { ni = Math.max(ni, m[i].reduce((s, v) => s + Math.abs(v), 0)); nF += m[i].reduce((s, v) => s + v * v, 0); } return { norm1: n1, normInf: ni, normFrobenius: Math.sqrt(nF) }; }
            function isDiagonallyDominant(A) { for (let i = 0; i < A.length; i++) { let diag = Math.abs(A[i][i]); let sum = 0; for (let j = 0; j < A.length; j++) { if (i !== j) sum += Math.abs(A[i][j]); } if (diag <= sum) return false; } return true; }
            function jacobiEig(A) { const n = A.length; let D = A.map(r => [...r]); let V = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))); if (n <= 1) return { eigenvalues: n === 1 ? [D[0][0]] : [], eigenvectors: V }; for (let iter = 0; iter < 100; iter++) { let p = 0, q = 1, maxVal = Math.abs(D[0][1] || 0); for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) if (Math.abs(D[i][j]) > maxVal) { maxVal = Math.abs(D[i][j]); p = i; q = j; } if (maxVal < EPSILON) break; const d_pq = D[p][q], d_pp = D[p][p], d_qq = D[q][q]; const tau = (d_qq - d_pp) / (2 * d_pq); const t = Math.sign(tau || 1) / (Math.abs(tau) + Math.sqrt(1 + tau * tau)); const c = 1 / Math.sqrt(1 + t * t); const s = t * c; const Dp_orig = [...D[p]], Dq_orig = [...D[q]]; D[p][p] = d_pp - t * d_pq; D[q][q] = d_qq + t * d_pq; D[p][q] = D[q][p] = 0; for (let k = 0; k < n; k++) { if (k !== p && k !== q) { D[k][p] = D[p][k] = c * Dp_orig[k] - s * Dq_orig[k]; D[k][q] = D[q][k] = s * Dp_orig[k] + c * Dq_orig[k]; } } for (let k = 0; k < n; k++) { const V_kp = V[k][p], V_kq = V[k][q]; V[k][p] = c * V_kp - s * V_kq; V[k][q] = s * V_kp + c * V_kq; } } return { eigenvalues: D.map((r, i) => r[i]), eigenvectors: V }; }
            function completeOrthonormalBasis(vectors, dim) { const basis = vectors.map(v => [...v]); for (let i = 0; i < dim && basis.length < dim; i++) { let e = Array(dim).fill(0); e[i] = 1; let v = e; for (const b of basis) v = subtractVectors(v, scalarMultiply(dot(e, b), b)); if (norm(v) > EPSILON) basis.push(normalize(v)); } return basis; }

            // --- MAIN CALCULATION FUNCTIONS ---
            function jacobiMethod(A, b, maxIter = 100, tolerance = 1e-7) {
                  const n = A.length;
                  for (let i = 0; i < n; i++) { if (Math.abs(A[i][i]) < EPSILON) return { converged: false, message: `–ù—É–ª—å–æ–≤–∏–π –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç A[${i + 1},${i + 1}].` }; }
                  const dominance = isDiagonallyDominant(A);
                  let x = Array(n).fill(0);
                  const iterationHistory = [{ vector: [...x], calcs: Array(n).fill("–ü–æ—á–∞—Ç–∫–æ–≤–µ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è") }];
                  for (let iter = 0; iter < maxIter; iter++) {
                        const x_new = Array(n).fill(0);
                        const calcs = [];
                        for (let i = 0; i < n; i++) {
                              let sum = 0;
                              let formula = `( ${b[i]}`;
                              for (let j = 0; j < n; j++) {
                                    if (i !== j) {
                                          sum += A[i][j] * x[j];
                                          formula += ` - (${A[i][j]})*(${x[j].toFixed(4)})`;
                                    }
                              }
                              x_new[i] = (b[i] - sum) / A[i][i];
                              formula += ` ) / ${A[i][i]} = ${x_new[i].toFixed(7)}`;
                              calcs.push(formula);
                        }
                        iterationHistory.push({ vector: [...x_new], calcs: calcs });
                        if (norm(subtractVectors(x_new, x)) < tolerance) {
                              return { converged: true, solution: x_new, iterations: iter + 1, isDominant: dominance, residual: subtractVectors(b, multiplyMatrixVector(A, x_new)), iterationHistory };
                        }
                        x = x_new;
                  }
                  return { converged: false, message: `–ú–µ—Ç–æ–¥ –Ω–µ –∑—ñ–π—à–æ–≤—Å—è –∑–∞ ${maxIter} —ñ—Ç–µ—Ä–∞—Ü—ñ–π.`, isDominant: dominance, iterationHistory };
            }

            function powerIterationWithDeflation(A, numEigen) {
                  let currentA = A.map(row => [...row]);
                  const eigenvalues = [];
                  const eigenvectors = [];
                  for (let i = 0; i < numEigen; i++) {
                        let b_k = Array(A.length).fill(1);
                        let eigenvalue;
                        for (let iter = 0; iter < 100; iter++) {
                              const Ab_k = multiplyMatrixVector(currentA, b_k);
                              b_k = normalize(Ab_k);
                        }
                        const Ab_k = multiplyMatrixVector(currentA, b_k);
                        eigenvalue = dot(b_k, Ab_k);
                        eigenvalues.push(eigenvalue);
                        eigenvectors.push(b_k);
                        const deflationMatrix = outerProduct(b_k, b_k);
                        currentA = subtractMatrices(currentA, deflationMatrix.map(row => row.map(val => val * eigenvalue)));
                  }
                  return { eigenvalues, eigenvectors };
            }

            function calculateSVD(A) { const m = A.length, n = A[0].length; const At = transpose(A); const AtA = multiply(At, A); const { eigenvalues, eigenvectors: V_unordered } = jacobiEig(AtA); const eigPairs = eigenvalues.map((v, i) => ({ val: v, vec: V_unordered.map(r => r[i]) })).sort((a, b) => b.val - a.val); const singularValues = eigPairs.map(p => Math.sqrt(Math.max(0, p.val))); const V = transpose(eigPairs.map(p => p.vec)); let U_cols = []; for (let i = 0; i < n; i++) { if (singularValues[i] > EPSILON) { const u_col = multiplyMatrixVector(A, V.map(r => r[i])); U_cols.push(normalize(u_col)); } } if (m > U_cols.length) { U_cols = completeOrthonormalBasis(U_cols, m); } const U = transpose(U_cols); const Sigma = Array(m).fill(0).map(() => Array(n).fill(0)); singularValues.forEach((s, i) => { if (i < m && i < n) Sigma[i][i] = s; }); return { U, Sigma, V, singularValues }; }
            function getInverseMatrix(A) { const n = A.length; if (n !== A[0].length) throw new Error("M is not square."); const aug = A.map((r, i) => [...r, ...Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))]); for (let i = 0; i < n; i++) { let max = i; for (let k = i + 1; k < n; k++) if (Math.abs(aug[k][i]) > Math.abs(aug[max][i])) max = k;[aug[i], aug[max]] = [aug[max], aug[i]]; if (Math.abs(aug[i][i]) < EPSILON) throw new Error("M is singular."); const p = aug[i][i]; for (let j = i; j < 2 * n; j++) aug[i][j] /= p; for (let k = 0; k < n; k++) if (k !== i) { const f = aug[k][i]; for (let j = i; j < 2 * n; j++) aug[k][j] -= f * aug[i][j]; } } return aug.map(r => r.slice(n)); }
            function calculateLowRank(U, Sigma, V, k) { const Uk = transpose(transpose(U).slice(0, k)); const Sk = Sigma.slice(0, k).map(r => r.slice(0, k)); const Vk = transpose(transpose(V).slice(0, k)); return multiply(multiply(Uk, Sk), transpose(Vk)); }

            function matrixOperations(matrix, b) {
                  const rows = matrix.length, cols = matrix[0].length, isSquare = rows === cols;
                  let results = {};

                  results.norms = getNorms(matrix);
                  results.svd = calculateSVD(matrix);

                  const { U, Sigma, V } = results.svd;
                  const k = parseInt(document.getElementById('rankK').value);
                  const maxRank = Math.min(rows, cols);
                  if (isNaN(k) || k < 1 || k > maxRank) {
                        results.lowRank = `–ù–µ–≤—ñ—Ä–Ω–∏–π —Ä–∞–Ω–≥ k. –û–±–µ—Ä—ñ—Ç—å k –≤—ñ–¥ 1 –¥–æ ${maxRank}.`;
                  } else {
                        const A_k = calculateLowRank(U, Sigma, V, k);
                        results.lowRank = { matrix: A_k, rank: k };
                  }

                  if (isSquare) {
                        results.eigen = powerIterationWithDeflation(matrix, rows);
                        try {
                              results.inverse = getInverseMatrix(matrix);
                              const normsA_inv = getNorms(results.inverse);
                              const sigmas = results.svd.singularValues;
                              const cond2 = (sigmas[sigmas.length - 1] < EPSILON) ? "‚àû" : (sigmas[0] / sigmas[sigmas.length - 1]);
                              results.conditionNumbers = {
                                    cond1: results.norms.norm1 * normsA_inv.norm1,
                                    condInf: results.norms.normInf * normsA_inv.normInf,
                                    condFrobenius: results.norms.normFrobenius * normsA_inv.normFrobenius,
                                    cond2
                              };
                        } catch (e) {
                              results.inverse = "–ú–∞—Ç—Ä–∏—Ü—è –≤–∏—Ä–æ–¥–∂–µ–Ω–∞.";
                              results.conditionNumbers = { cond1: "‚àû", condInf: "‚àû", condFrobenius: "‚àû", cond2: "‚àû" };
                        }
                        if (b) results.jacobi = jacobiMethod(matrix, b, 100, 1e-7);
                  } else {
                        results.inverse = "–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–Ω–∞.";
                        results.conditionNumbers = "–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–Ω–∞.";
                        results.jacobi = "–ú–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                        results.eigen = "–ú–µ—Ç–æ–¥ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                  }
                  return results;
            }

            // --- DISPLAY FUNCTIONS ---
            function formatMatrix(m, name, precision = 7) { if (!m || !m[0]) return ""; return `${name}:\n` + m.map(r => `| ${r.map(v => v.toFixed(precision).padStart(12, ' ')).join(' ')} |`).join('\n'); }
            function formatVector(v, name, precision = 7) { return `${name}:\n` + v.map(val => `| ${val.toFixed(precision).padStart(12, ' ')} |`).join('\n'); }

            function displayResults(result) {
                  const resultsDiv = document.getElementById('results');
                  let output = "--- –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –û–±—á–∏—Å–ª–µ–Ω—å ---\n";
                  const h_line = "\n" + "-".repeat(60) + "\n\n";

                  // 1. Jacobi Method
                  output += "1. –†–æ–∑–≤'—è–∑–æ–∫ –°–õ–ê–† –º–µ—Ç–æ–¥–æ–º –Ø–∫–æ–±—ñ (Ax = b)\n";
                  if (typeof result.jacobi === 'string') { output += result.jacobi + "\n"; }
                  else if (result.jacobi) {
                        if (result.jacobi.converged) {
                              output += `\n–ú–∞—Ç—Ä–∏—Ü—è ${result.jacobi.isDominant ? '—î' : '–ù–ï —î'} –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é (—É–º–æ–≤–∞ –∑–±—ñ–∂–Ω–æ—Å—Ç—ñ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è).\n`;
                              output += `–ú–µ—Ç–æ–¥ –∑—ñ–π—à–æ–≤—Å—è –∑–∞ ${result.jacobi.iterations} —ñ—Ç–µ—Ä–∞—Ü—ñ–π –∑ —Ç–æ—á–Ω—ñ—Å—Ç—é 1e-7.\n\n`;
                              output += formatVector(result.jacobi.solution, "x (—Ñ—ñ–Ω–∞–ª—å–Ω–∏–π —Ä–æ–∑–≤'—è–∑–æ–∫)") + "\n";
                        } else {
                              output += `\n–ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è: ${result.jacobi.isDominant ? '–ú–∞—Ç—Ä–∏—Ü—è —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é, –∞–ª–µ –º–µ—Ç–æ–¥ –Ω–µ –∑—ñ–π—à–æ–≤—Å—è.' : '–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é (–∑–±—ñ–∂–Ω—ñ—Å—Ç—å –Ω–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞).'}\n`;
                              output += result.jacobi.message + "\n";
                        }
                        if (result.jacobi.iterationHistory) {
                              output += "\n--- –î–µ—Ç–∞–ª—å–Ω—ñ –Ü—Ç–µ—Ä–∞—Ü—ñ—ó –ú–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ ---\n";
                              result.jacobi.iterationHistory.forEach((hist, k) => {
                                    output += `\n--- –Ü—Ç–µ—Ä–∞—Ü—ñ—è ${k} ---\n`;
                                    output += formatVector(hist.vector, `x^(${k})`);
                                    if (k > 0) {
                                          output += "\n–†–æ–∑—Ä–∞—Ö—É–Ω–∫–∏:\n";
                                          hist.calcs.forEach((calc, i) => {
                                                output += ` x_${i + 1}^(${k}) = ${calc}\n`;
                                          });
                                    }
                              });
                        }
                  }
                  output += h_line;

                  // 2. Eigenvalues and Eigenvectors
                  output += "2. –í–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞ —Ç–∞ –≤–µ–∫—Ç–æ—Ä–∏ (–°—Ç–µ–ø–µ–Ω–µ–≤–∏–π –º–µ—Ç–æ–¥ + –¥–µ—Ñ–ª—è—Ü—ñ—è)\n\n";
                  if (typeof result.eigen === 'string') { output += result.eigen + "\n"; }
                  else if (result.eigen) {
                        for (let i = 0; i < result.eigen.eigenvalues.length; i++) {
                              output += `–í–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ Œª_${i + 1}: ${result.eigen.eigenvalues[i].toFixed(7)}\n`;
                              output += formatVector(result.eigen.eigenvectors[i], `–í–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä v_${i + 1}`) + "\n\n";
                        }
                  }
                  output += h_line;

                  // 3. Low-Rank Approximation
                  output += `3. –ù–∏–∑—å–∫–æ—Ä–∞–Ω–≥–æ–≤–µ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è (A_k) —Ä–∞–Ω–≥—É k=${result.lowRank.rank}\n\n`;
                  if (typeof result.lowRank === 'string') { output += result.lowRank + "\n"; }
                  else {
                        output += formatMatrix(result.lowRank.matrix, `A_k (—Ä–∞–Ω–≥ k=${result.lowRank.rank})`) + "\n";
                  }
                  output += h_line;

                  // 4. Condition Numbers
                  output += "4. –ß–∏—Å–ª–æ –æ–±—É–º–æ–≤–ª–µ–Ω–æ—Å—Ç—ñ (Œ∫)\n\n";
                  if (typeof result.conditionNumbers === 'string') output += result.conditionNumbers + "\n";
                  else {
                        output += `1. –ó–∞ –Ω–æ—Ä–º–æ—é 1 (—Å—Ç–æ–≤–ø—Ü–µ–≤–∞): Œ∫‚ÇÅ(A) = ${result.conditionNumbers.cond1.toFixed(4)}\n`;
                        output += `2. –ó–∞ –Ω–æ—Ä–º–æ—é ‚àû (—Ä—è–¥–∫–æ–≤–∞):   Œ∫_inf(A) = ${result.conditionNumbers.condInf.toFixed(4)}\n`;
                        output += `3. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞ (–Ω–æ—Ä–º–∞ 2):    Œ∫‚ÇÇ(A) = ${result.conditionNumbers.cond2.toFixed(4)}\n`;
                        output += `4. –ó–∞ –Ω–æ—Ä–º–æ—é –§—Ä–æ–±–µ–Ω—ñ—É—Å–∞:     Œ∫_F(A) = ${result.conditionNumbers.condFrobenius.toFixed(4)}\n`;
                  }
                  output += h_line;

                  // 5. Additional Info (Norms, Inverse)
                  output += "5. –î–æ–¥–∞—Ç–∫–æ–≤–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è\n\n";
                  output += "–ù–æ—Ä–º–∏ –ú–∞—Ç—Ä–∏—Ü—ñ (A):\n";
                  output += `1. –ù–æ—Ä–º–∞ 1:          ||A||‚ÇÅ   = ${result.norms.norm1.toFixed(4)}\n`;
                  output += `2. –ù–æ—Ä–º–∞ ‚àû:          ||A||‚àû   = ${result.norms.normInf.toFixed(4)}\n`;
                  output += `3. –ù–æ—Ä–º–∞ –§—Ä–æ–±–µ–Ω—ñ—É—Å–∞: ||A||F   = ${result.norms.normFrobenius.toFixed(4)}\n\n`;

                  output += "–û–±–µ—Ä–Ω–µ–Ω–∞ –ú–∞—Ç—Ä–∏—Ü—è (A‚Åª¬π):\n";
                  if (typeof result.inverse === 'string') output += result.inverse + "\n";
                  else output += formatMatrix(result.inverse, 'A‚Åª¬π') + "\n";

                  resultsDiv.innerText = output;
            }

            window.onload = createMatrixInputs;
      </script>
</body>

</html>