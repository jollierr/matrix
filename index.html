<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ú–∞—Ç—Ä–∏—á–Ω–∏–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä: –ü–æ–≤–Ω–∏–π –†–æ–∑–≤'—è–∑–æ–∫ –∑ –¢–µ–æ—Ä—ñ—î—é</title>
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/8801/8801287.png" type="image/x-icon" />
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 20px;
            background-color: #f8f9fa;
            color: #212529;
            line-height: 1.6;
        }

        .container {
            max-width: 1100px;
            margin: auto;
            background: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #dee2e6;
        }

        h1 {
            color: #343a40;
            text-align: center;
            margin-bottom: 25px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            align-items: end;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
            color: #495057;
        }

        input[type="number"],
        input[type="text"] {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        input:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 12px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.2s;
            width: 100%;
        }

        button:hover {
            background-color: #0056b3;
        }

        #matrixInput {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }

        .matrix-row {
            display: flex;
            gap: 10px;
        }

        .matrix-row input {
            text-align: center;
            flex: 1;
        }

        #results {
            margin-top: 25px;
            padding: 0;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background-color: #ffffff;
            font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 14px;
            overflow: hidden;
        }
        
        .result-section {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
        }
        .result-section:last-child {
            border-bottom: none;
        }
        
        .result-section h3 {
            margin-top: 0;
            font-size: 18px;
            color: #0056b3;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .theory-block, .formula-block {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            white-space: pre-wrap;
            line-height: 1.7;
            border: 1px solid #e9ecef;
        }

        .formula-block {
             white-space: pre;
        }
        
        .matrix-display, .vector-display {
            white-space: pre;
            line-height: 1.7;
            margin: 15px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .conclusion {
            font-weight: bold;
            color: #155724;
            background-color: #d4edda;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            border: 1px solid #c3e6cb;
        }
        
        .warning {
             font-weight: bold;
             color: #721c24;
             background-color: #f8d7da;
             padding: 12px;
             border-radius: 6px;
             margin-top: 15px;
             border: 1px solid #f5c6cb;
        }

        .error-message {
            color: #721c24;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>–ú–∞—Ç—Ä–∏—á–Ω–∏–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä üìä</h1>
        <div class="controls-grid">
            <div>
                <label for="rowsSize">–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤ (M):</label>
                <input type="number" id="rowsSize" min="1" max="10" value="3" onchange="createMatrixInputs()">
            </div>
            <div>
                <label for="colsSize">–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Å—Ç–æ–≤–ø—Ü—ñ–≤ (N):</label>
                <input type="number" id="colsSize" min="1" max="10" value="3" onchange="createMatrixInputs()">
            </div>
            <div>
                <label for="rankK">–†–∞–Ω–≥ –¥–ª—è –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è (k):</label>
                <input type="number" id="rankK" min="1" value="2" onchange="updateRankKMax()">
            </div>
        </div>
        <div>
            <label>–í–≤–µ–¥—ñ—Ç—å –µ–ª–µ–º–µ–Ω—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ñ A:</label>
            <div id="matrixInput"></div>
        </div>
        <div id="vectorBContainer" style="margin-top: 15px;">
            <label>–í–≤–µ–¥—ñ—Ç—å –≤–µ–∫—Ç–æ—Ä b (–¥–ª—è –º–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ):</label>
            <div id="vectorBInput"></div>
        </div>
        <button onclick="calculate()" style="margin-top: 15px;">–û–±—á–∏—Å–ª–∏—Ç–∏</button>
        <div id="results"></div>
    </div>

    <script>
        const defaultMatrixValues = [[2, 0, 18], [11, 0.5, -3], [1, 18, -3]];
        const defaultVectorBValues = [-3, -5, -10];
        const EPSILON = 1e-10;

        // --- UI FUNCTIONS ---
        function updateRankKMax() { const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value), rankKInput = document.getElementById('rankK'); if (!isNaN(M) && !isNaN(N)) { rankKInput.max = Math.min(M, N); } }
        function createMatrixInputs() {
            const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value);
            const matrixContainer = document.getElementById('matrixInput'), vectorBContainer = document.getElementById('vectorBContainer'), vectorBInput = document.getElementById('vectorBInput');
            if (M < 1 || M > 10 || isNaN(M) || N < 1 || N > 10 || isNaN(N)) { matrixContainer.innerHTML = `<span class="error-message">–†–æ–∑–º—ñ—Ä –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –≤—ñ–¥ 1 –¥–æ 10.</span>`; vectorBContainer.style.display = 'none'; return; }
            matrixContainer.innerHTML = '';
            for (let i = 0; i < M; i++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'matrix-row';
                for (let j = 0; j < N; j++) {
                    const input = document.createElement('input');
                    input.type = 'text'; input.id = `m-${i}-${j}`;
                    if (M === 3 && N === 3 && defaultMatrixValues[i]?.[j] !== undefined) input.value = defaultMatrixValues[i][j];
                    else if (M === N) input.value = (i === j) ? '1' : '0';
                    else input.value = '0';
                    rowDiv.appendChild(input);
                }
                matrixContainer.appendChild(rowDiv);
            }
            if (M === N) {
                vectorBContainer.style.display = 'block'; vectorBInput.innerHTML = '';
                const rowDiv = document.createElement('div'); rowDiv.className = 'matrix-row';
                for (let i = 0; i < M; i++) {
                    const input = document.createElement('input');
                    input.type = 'text'; input.id = `v-${i}`;
                    input.value = (M === 3 && defaultVectorBValues[i] !== undefined) ? defaultVectorBValues[i] : i + 1;
                    rowDiv.appendChild(input);
                }
                vectorBInput.appendChild(rowDiv);
            } else { vectorBContainer.style.display = 'none'; vectorBInput.innerHTML = ''; }
            updateRankKMax();
        }
        
        function calculate() {
            const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value);
            let matrix = [];
            for (let i = 0; i < M; i++) {
                let row = [];
                for (let j = 0; j < N; j++) {
                    const value = parseFloat(document.getElementById(`m-${i}-${j}`).value.replace(',', '.'));
                    if (isNaN(value)) { document.getElementById('results').innerHTML = `<div class="error-message">–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —É –ø–æ–ª—ñ [${i + 1},${j + 1}].</div>`; return; }
                    row.push(value);
                }
                matrix.push(row);
            }
            let vectorB = null;
            if (M === N) {
                vectorB = [];
                for (let i = 0; i < M; i++) {
                    const value = parseFloat(document.getElementById(`v-${i}`).value.replace(',', '.'));
                    if (isNaN(value)) { document.getElementById('results').innerHTML = `<div class="error-message">–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —É –≤–µ–∫—Ç–æ—Ä—ñ b, –ø–æ–∑–∏—Ü—ñ—è [${i + 1}].</div>`; return; }
                    vectorB.push(value);
                }
            }
            
            const originalMatrix = JSON.parse(JSON.stringify(matrix));
            let rearrangementInfo = { wasRearranged: false };
            let matrixForCalc = JSON.parse(JSON.stringify(matrix));
            let vectorBForCalc = vectorB ? [...vectorB] : null;

            if(M === N && !isDiagonallyDominant(matrixForCalc)) {
                const permuteResult = tryPermuteForDominance(matrixForCalc, vectorBForCalc);
                if (permuteResult.success) {
                    matrixForCalc = permuteResult.A;
                    vectorBForCalc = permuteResult.b;
                    rearrangementInfo = {
                        wasRearranged: true,
                        message: "–ü–û–ü–ï–†–ï–î–ñ–ï–ù–ù–Ø: –ü–æ—á–∞—Ç–∫–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü—è –Ω–µ —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é. –°–∏—Å—Ç–µ–º—É –±—É–ª–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–æ –¥–ª—è –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –∑–±—ñ–∂–Ω–æ—Å—Ç—ñ –º–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ.",
                    };
                } else {
                     rearrangementInfo = {
                        wasRearranged: false,
                        message: "–ü–û–ü–ï–†–ï–î–ñ–ï–ù–ù–Ø: –ú–∞—Ç—Ä–∏—Ü—è –Ω–µ —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é, —ñ –Ω–µ –≤–¥–∞–ª–æ—Å—è –¥–æ—Å—è–≥—Ç–∏ —Ü—å–æ–≥–æ —à–ª—è—Ö–æ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ä—è–¥–∫—ñ–≤. –ó–±—ñ–∂–Ω—ñ—Å—Ç—å –Ω–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞."
                    };
                }
            }

            const result = matrixOperations(matrixForCalc, vectorBForCalc);
            displayResults(result, matrixForCalc, originalMatrix, rearrangementInfo);
        }

        // --- LINEAR ALGEBRA HELPERS ---
        function transpose(m) { if (!m || !m.length || !m[0].length) return []; return m[0].map((_, c) => m.map(r => r[c])); }
        function multiply(a, b) { return a.map(row => b[0].map((_, j) => row.reduce((sum, val, k) => sum + val * b[k][j], 0))); }
        function multiplyMatrixVector(A, v) { return A.map(r => r.reduce((s, x, j) => s + x * v[j], 0)); }
        function dot(v1, v2) { return v1.reduce((s, x, i) => s + x * v2[i], 0); }
        function norm(v) { return Math.sqrt(dot(v, v)); }
        function normalize(v) { const n = norm(v); return (n < EPSILON) ? v.map(() => 0) : v.map(x => x / n); }
        function subtractVectors(v1, v2) { return v1.map((x, i) => x - v2[i]); }
        function scalarMultiply(s, v) { return v.map(x => s * x); }
        function subtractMatrices(A, B) { return A.map((row, i) => row.map((val, j) => val - B[i][j])); }
        function getNorms(m) { let n1 = 0, ni = 0, nF = 0; if (!m.length) return { n1, ni, nF }; for (let j = 0; j < m[0].length; j++) n1 = Math.max(n1, m.reduce((s, r) => s + Math.abs(r[j]), 0)); for (let i = 0; i < m.length; i++) { ni = Math.max(ni, m[i].reduce((s, v) => s + Math.abs(v), 0)); nF += m[i].reduce((s, v) => s + v * v, 0); } return { norm1: n1, normInf: ni, normFrobenius: Math.sqrt(nF) }; }
        function isDiagonallyDominant(A) { for (let i = 0; i < A.length; i++) { let diag = Math.abs(A[i][i]); let sum = 0; for (let j = 0; j < A.length; j++) { if (i !== j) sum += Math.abs(A[i][j]); } if (diag <= sum) return false; } return true; }

        // --- MAIN CALCULATION FUNCTIONS ---
        function tryPermuteForDominance(A, b) {
            const n = A.length;
            const permutation = new Array(n);
            const used_rows = new Array(n).fill(false);
            function findPermutation(k) {
                if (k === n) { return true; } 
                for (let i = 0; i < n; i++) { 
                    if (!used_rows[i]) {
                        let off_diag_sum = 0;
                        for (let j = 0; j < n; j++) { if (j !== k) { off_diag_sum += Math.abs(A[i][j]); } }
                        if (Math.abs(A[i][k]) > off_diag_sum) {
                            permutation[k] = i;
                            used_rows[i] = true;
                            if (findPermutation(k + 1)) { return true; }
                            used_rows[i] = false;
                        }
                    }
                }
                return false;
            }
            if (findPermutation(0)) {
                const permutedA = new Array(n).fill(0).map(() => new Array(n));
                const permutedB = new Array(n);
                for (let i = 0; i < n; i++) {
                    permutedA[i] = [...A[permutation[i]]];
                    if (b) permutedB[i] = b[permutation[i]];
                }
                return { success: true, A: permutedA, b: permutedB };
            }
            return { success: false, A, b };
        }
        
        function jacobiMethod(A, b, maxIter = 100, tolerance = 1e-7) {
            const n = A.length;
            for (let i = 0; i < n; i++) { if (Math.abs(A[i][i]) < EPSILON) return { converged: false, message: `–ù—É–ª—å–æ–≤–∏–π –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç A[${i + 1},${i + 1}].` }; }
            const dominance = isDiagonallyDominant(A);
            let x = Array(n).fill(0);
            const iterationHistory = [{ vector: [...x], calcs: Array(n).fill("–ü–æ—á–∞—Ç–∫–æ–≤–µ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è") }];
            for (let iter = 0; iter < maxIter; iter++) {
                const x_new = Array(n).fill(0);
                const calcs = [];
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    let formula = `( ${b[i]}`;
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            sum += A[i][j] * x[j];
                            formula += ` - (${A[i][j]})*(${x[j].toFixed(4)})`;
                        }
                    }
                    x_new[i] = (b[i] - sum) / A[i][i];
                    formula += ` ) / ${A[i][i]} = ${x_new[i].toFixed(7)}`;
                    calcs.push(formula);
                }
                iterationHistory.push({ vector: [...x_new], calcs: calcs });
                if (norm(subtractVectors(x_new, x)) < tolerance) {
                    return { converged: true, solution: x_new, iterations: iter + 1, isDominant: dominance, residual: subtractVectors(b, multiplyMatrixVector(A, x_new)), iterationHistory };
                }
                x = x_new;
            }
            return { converged: false, message: `–ú–µ—Ç–æ–¥ –Ω–µ –∑—ñ–π—à–æ–≤—Å—è –∑–∞ ${maxIter} —ñ—Ç–µ—Ä–∞—Ü—ñ–π.`, isDominant: dominance, iterationHistory };
        }

        function findEigenvaluesNewton(A) {
            if (A.length !== 3) return { error: "–ú–µ—Ç–æ–¥ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ —Ç—ñ–ª—å–∫–∏ –¥–ª—è –º–∞—Ç—Ä–∏—Ü—å 3x3." };
            const tr = A[0][0] + A[1][1] + A[2][2];
            const det = A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1]) - A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0]) + A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);
            const m11 = A[1][1] * A[2][2] - A[1][2] * A[2][1];
            const m22 = A[0][0] * A[2][2] - A[0][2] * A[2][0];
            const m33 = A[0][0] * A[1][1] - A[0][1] * A[1][0];
            const sum_minors = m11 + m22 + m33;
            const p = (l) => -l * l * l + tr * l * l - sum_minors * l + det;
            const p_prime = (l) => -3 * l * l + 2 * tr * l - sum_minors;
            let lambda1 = tr / 3; 
            for (let i = 0; i < 50; i++) {
                const p_val = p(lambda1);
                const p_prime_val = p_prime(lambda1);
                if (Math.abs(p_prime_val) < EPSILON) break;
                const next_lambda = lambda1 - p_val / p_prime_val;
                if (Math.abs(next_lambda - lambda1) < EPSILON) break;
                lambda1 = next_lambda;
            }
            const a = -1, b = tr - lambda1, c = -sum_minors + lambda1 * b;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return { error: "–ó–Ω–∞–π–¥–µ–Ω–æ –∫–æ–º–ø–ª–µ–∫—Å–Ω—ñ –∫–æ—Ä–µ–Ω—ñ, —è–∫—ñ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å—Å—è." };
            const lambda2 = (-b + Math.sqrt(discriminant)) / (2 * a);
            const lambda3 = (-b - Math.sqrt(discriminant)) / (2 * a);
            const poly_str = `p(Œª) = -Œª¬≥ + (${tr.toFixed(3)})Œª¬≤ - (${sum_minors.toFixed(3)})Œª + (${det.toFixed(3)}) = 0`;
            return { eigenvalues: [lambda1, lambda2, lambda3].sort((x, y) => y - x), polynomial: poly_str };
        }

        function findEigenpairsIterative(A) {
            const n = A.length;
            if (n === 0) return { eigenvalues: [], eigenvectors: [] };
            let eigenvalues = [], eigenvectors = [];
            
            let v_dom = Array(n).fill(1);
            for (let i = 0; i < 100; i++) { v_dom = normalize(multiplyMatrixVector(A, v_dom)); }
            let lambda_dom = dot(v_dom, multiplyMatrixVector(A, v_dom));
            eigenvalues.push(lambda_dom);
            eigenvectors.push(v_dom);
            
            let A_inv, lambda_min, v_min;
            try {
                A_inv = getInverseMatrix(A);
                v_min = Array(n).fill(1);
                for (let i = 0; i < 100; i++) { v_min = normalize(multiplyMatrixVector(A_inv, v_min)); }
                lambda_min = 1 / dot(v_min, multiplyMatrixVector(A_inv, v_min));
            } catch (e) { return { eigenvalues, eigenvectors, error: "–ú–∞—Ç—Ä–∏—Ü—è –≤–∏—Ä–æ–¥–∂–µ–Ω–∞, –Ω–µ–º–æ–∂–ª–∏–≤–æ –∑–Ω–∞–π—Ç–∏ –≤—Å—ñ –≤–ª–∞—Å–Ω—ñ –ø–∞—Ä–∏." }; }

            if (Math.abs(dot(v_dom, v_min)) < 0.99) {
                eigenvalues.push(lambda_min);
                eigenvectors.push(v_min);
            }

            if (n === 3 && eigenvalues.length === 2) {
                const tr = A[0][0] + A[1][1] + A[2][2];
                const lambda_mid = tr - lambda_dom - lambda_min;
                const shift = lambda_mid + (Math.random() - 0.5) * 1e-6; 
                let B = A.map((row, i) => row.map((val, j) => val - (i === j ? shift : 0)));
                let B_inv, v_mid;
                try {
                    B_inv = getInverseMatrix(B);
                    v_mid = Array(n).fill(1);
                    for (let i = 0; i < 100; i++) { v_mid = normalize(multiplyMatrixVector(B_inv, v_mid)); }
                    eigenvalues.push(lambda_mid);
                    eigenvectors.push(v_mid);
                } catch(e) {}
            }
            const pairs = eigenvalues.map((val, i) => ({ eigenvalue: val, eigenvector: eigenvectors[i] })).sort((a, b) => Math.abs(b.eigenvalue) - Math.abs(a.eigenvalue));
            return { eigenvalues: pairs.map(p => p.eigenvalue), eigenvectors: pairs.map(p => p.eigenvector) };
        }

        function jacobiEig(A) { const n = A.length; let D = A.map(r => [...r]); let V = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))); if (n <= 1) return { eigenvalues: n === 1 ? [D[0][0]] : [], eigenvectors: V }; for (let iter = 0; iter < 100; iter++) { let p = 0, q = 1, maxVal = Math.abs(D[0][1] || 0); for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) if (Math.abs(D[i][j]) > maxVal) { maxVal = Math.abs(D[i][j]); p = i; q = j; } if (maxVal < EPSILON) break; const d_pq = D[p][q], d_pp = D[p][p], d_qq = D[q][q]; const tau = (d_qq - d_pp) / (2 * d_pq); const t = Math.sign(tau || 1) / (Math.abs(tau) + Math.sqrt(1 + tau * tau)); const c = 1 / Math.sqrt(1 + t * t); const s = t * c; const Dp_orig = [...D[p]], Dq_orig = [...D[q]]; D[p][p] = d_pp - t * d_pq; D[q][q] = d_qq + t * d_pq; D[p][q] = D[q][p] = 0; for (let k = 0; k < n; k++) { if (k !== p && k !== q) { D[k][p] = D[p][k] = c * Dp_orig[k] - s * Dq_orig[k]; D[k][q] = D[q][k] = s * Dp_orig[k] + c * Dq_orig[k]; } } for (let k = 0; k < n; k++) { const V_kp = V[k][p], V_kq = V[k][q]; V[k][p] = c * V_kp - s * V_kq; V[k][q] = s * V_kp + c * V_kq; } } return { eigenvalues: D.map((r, i) => r[i]), eigenvectors: V }; }
        function calculateSVD(A) { const m = A.length, n = A[0].length; const At = transpose(A); const AtA = multiply(At, A); const { eigenvalues, eigenvectors: V_unordered } = jacobiEig(AtA); const eigPairs = eigenvalues.map((v, i) => ({ val: v, vec: V_unordered.map(r => r[i]) })).sort((a, b) => b.val - a.val); const singularValues = eigPairs.map(p => Math.sqrt(Math.max(0, p.val))); const V = transpose(eigPairs.map(p => p.vec)); let U_cols = []; for (let i = 0; i < n; i++) { if (singularValues[i] > EPSILON) { const u_col = multiplyMatrixVector(A, V.map(r => r[i])); U_cols.push(normalize(u_col)); } } const U = transpose(U_cols); const Sigma = Array(m).fill(0).map(() => Array(n).fill(0)); singularValues.forEach((s, i) => { if (i < m && i < n) Sigma[i][i] = s; }); return { U, Sigma, V, singularValues }; }
        function getInverseMatrix(A) { const n = A.length; if (n !== A[0].length) throw new Error("M is not square."); const aug = A.map((r, i) => [...r, ...Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))]); for (let i = 0; i < n; i++) { let max = i; for (let k = i + 1; k < n; k++) if (Math.abs(aug[k][i]) > Math.abs(aug[max][i])) max = k;[aug[i], aug[max]] = [aug[max], aug[i]]; if (Math.abs(aug[i][i]) < EPSILON) throw new Error("M is singular."); const p = aug[i][i]; for (let j = i; j < 2 * n; j++) aug[i][j] /= p; for (let k = 0; k < n; k++) if (k !== i) { const f = aug[k][i]; for (let j = i; j < 2 * n; j++) aug[k][j] -= f * aug[i][j]; } } return aug.map(r => r.slice(n)); }
        function calculateLowRank(U, Sigma, V, k) { const Uk = transpose(transpose(U).slice(0, k)); const Sk = Sigma.slice(0, k).map(r => r.slice(0, k)); const Vk = transpose(transpose(V).slice(0, k)); return multiply(multiply(Uk, Sk), transpose(Vk)); }

        function matrixOperations(matrix, b) {
            const rows = matrix.length, cols = matrix[0].length, isSquare = rows === cols;
            let results = {};

            results.norms = getNorms(matrix);
            results.svd = calculateSVD(matrix);

            const { U, Sigma, V } = results.svd;
            const k = parseInt(document.getElementById('rankK').value);
            const maxRank = Math.min(rows, cols);
            if (isNaN(k) || k < 1 || k > maxRank) {
                results.lowRank = `–ù–µ–≤—ñ—Ä–Ω–∏–π —Ä–∞–Ω–≥ k. –û–±–µ—Ä—ñ—Ç—å k –≤—ñ–¥ 1 –¥–æ ${maxRank}.`;
            } else {
                results.lowRank = { matrix: calculateLowRank(U, Sigma, V, k), rank: k };
            }

            if (isSquare) {
                results.eigenNewton = findEigenvaluesNewton(matrix);
                results.eigenPower = findEigenpairsIterative(matrix); 
                try {
                    results.inverse = getInverseMatrix(matrix);
                    const normsA_inv = getNorms(results.inverse);
                    const sigmas = results.svd.singularValues;
                    const cond2 = (sigmas[sigmas.length - 1] < EPSILON) ? "‚àû" : (sigmas[0] / sigmas[sigmas.length - 1]);
                    results.conditionNumbers = {
                        cond1: results.norms.norm1 * normsA_inv.norm1,
                        condInf: results.norms.normInf * normsA_inv.normInf,
                        condFrobenius: results.norms.normFrobenius * normsA_inv.normFrobenius,
                        cond2
                    };
                } catch (e) {
                    results.inverse = "–ú–∞—Ç—Ä–∏—Ü—è –≤–∏—Ä–æ–¥–∂–µ–Ω–∞.";
                    results.conditionNumbers = { cond1: "‚àû", condInf: "‚àû", condFrobenius: "‚àû", cond2: "‚àû" };
                }
                if (b) results.jacobi = jacobiMethod(matrix, b, 100, 1e-7);
            } else {
                results.inverse = "–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–Ω–∞.";
                results.conditionNumbers = "–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–Ω–∞.";
                results.jacobi = "–ú–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                results.eigenNewton = "–ú–µ—Ç–æ–¥ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                results.eigenPower = "–ú–µ—Ç–æ–¥ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
            }
            return results;
        }

        // --- DISPLAY FUNCTIONS ---
        function formatMatrix(m, name, precision = 7) { 
            if (!m || !m[0]) return ""; 
            let content = `<strong>${name}:</strong>\n` + m.map(r => `| ${r.map(v => v.toFixed(precision).padStart(12, ' ')).join(' ')} |`).join('\n');
            return `<div class="matrix-display">${content}</div>`;
        }
        function formatVector(v, name, precision = 7) { 
            let content = `<strong>${name}:</strong>\n` + v.map(val => `| ${val.toFixed(precision).padStart(12, ' ')} |`).join('\n');
            return `<div class="vector-display">${content}</div>`;
        }

        function displayResults(result, matrixForCalc, originalMatrix, rearrangementInfo) {
            const resultsDiv = document.getElementById('results');
            let output = "";

            // --- Section 1: Jacobi Method ---
            let jacobiSection = `<div class="result-section"><h3>1) –†–æ–∑–≤'—è–∑–∞—Ç–∏ —Å–∏—Å—Ç–µ–º—É —Ä—ñ–≤–Ω—è–Ω—å –º–µ—Ç–æ–¥–æ–º –Ø–∫–æ–±—ñ</h3>`;
            jacobiSection += `<div class="theory-block"><strong>–¢–µ–æ—Ä—ñ—è:</strong> –ú–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ ‚Äî —Ü–µ –∫–ª–∞—Å–∏—á–Ω–∏–π —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è —Ä–æ–∑–≤'—è–∑–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º –ª—ñ–Ω—ñ–π–Ω–∏—Ö –∞–ª–≥–µ–±—Ä–∞—ó—á–Ω–∏—Ö —Ä—ñ–≤–Ω—è–Ω—å (–°–õ–ê–†) –≤–∏–≥–ª—è–¥—É Ax = b. –ô–æ–≥–æ —Å—É—Ç—å –ø–æ–ª—è–≥–∞—î —É –≤–∏—Ä–∞–∂–µ–Ω–Ω—ñ –∫–æ–∂–Ω–æ—ó –∑–º—ñ–Ω–Ω–æ—ó x_i –∑ i-–≥–æ —Ä—ñ–≤–Ω—è–Ω–Ω—è —á–µ—Ä–µ–∑ —ñ–Ω—à—ñ. –ü–æ—á–∏–Ω–∞—é—á–∏ –∑ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è (–∑–∞–∑–≤–∏—á–∞–π –Ω—É–ª—å–æ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞), –º–µ—Ç–æ–¥ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ —É—Ç–æ—á–Ω—é—î —Ä–æ–∑–≤'—è–∑–æ–∫ –Ω–∞ –∫–æ–∂–Ω—ñ–π —ñ—Ç–µ—Ä–∞—Ü—ñ—ó. –í–∞–∂–ª–∏–≤–æ—é —É–º–æ–≤–æ—é, —â–æ –≥–∞—Ä–∞–Ω—Ç—É—î –∑–±—ñ–∂–Ω—ñ—Å—Ç—å –º–µ—Ç–æ–¥—É, —î —Å—Ç—Ä–æ–≥–∞ –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∞ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω—ñ—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ñ A, –∫–æ–ª–∏ –º–æ–¥—É–ª—å –∫–æ–∂–Ω–æ–≥–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç–∞ –±—ñ–ª—å—à–∏–π –∑–∞ —Å—É–º—É –º–æ–¥—É–ª—ñ–≤ —Ä–µ—à—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —É –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–º—É —Ä—è–¥–∫—É.</div>`;
            
            if(rearrangementInfo.message) {
                 jacobiSection += `<div class="warning">${rearrangementInfo.message}</div>`;
                 jacobiSection += formatMatrix(originalMatrix, '–ü–æ—á–∞—Ç–∫–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü—è (A)');
                 jacobiSection += formatMatrix(matrixForCalc, "–ú–∞—Ç—Ä–∏—Ü—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω—å (A')");
            }
            jacobiSection += `<p><strong>–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –£–º–æ–≤–∏ –ó–±—ñ–∂–Ω–æ—Å—Ç—ñ (–î—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∞ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω—ñ—Å—Ç—å):</strong></p>`;
            
            if (matrixForCalc && matrixForCalc.length > 0) {
                 let checkText = `<div class="matrix-display">`;
                matrixForCalc.forEach((row, i) => {
                    const diag = Math.abs(row[i]);
                    let sum = 0;
                    let sumStr = [];
                    row.forEach((val, j) => {
                        if (i !== j) {
                            sum += Math.abs(val);
                            sumStr.push(`|${val}|`);
                        }
                    });
                    checkText += `–†—è–¥–æ–∫ ${i + 1}: |${row[i]}| > ${sumStr.join(' + ')}  =>  ${diag.toFixed(1)} > ${sum.toFixed(1)} -> <strong>${diag > sum ? 'OK' : 'FAIL'}</strong>\n`;
                });
                 checkText += `</div>`;
                 jacobiSection += checkText;
            }

            if (typeof result.jacobi === 'string') { jacobiSection += `<p>${result.jacobi}</p>`; }
            else if (result.jacobi) {
                jacobiSection += `<div class="conclusion">${result.jacobi.isDominant ? '–ú–∞—Ç—Ä–∏—Ü—è —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é. –ó–±—ñ–∂–Ω—ñ—Å—Ç—å –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞.' : '–ú–∞—Ç—Ä–∏—Ü—è –ù–ï —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é. –ó–±—ñ–∂–Ω—ñ—Å—Ç—å –Ω–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞.'}</div>`;
                jacobiSection += `<div class="formula-block">–§–æ—Ä–º—É–ª–∞ –¥–ª—è —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—É:
              1   ‚éõ      n              ‚éû
x_i^(k+1) = ---- ‚éú b_i -  Œ£  a_ij * x_j^(k) ‚éü
            a_ii ‚éù     j=1, j‚â†i         ‚é†</div>`;

                if (result.jacobi.converged) {
                    jacobiSection += `<p>–ú–µ—Ç–æ–¥ –∑—ñ–π—à–æ–≤—Å—è –∑–∞ <strong>${result.jacobi.iterations} —ñ—Ç–µ—Ä–∞—Ü—ñ–π</strong> –∑ —Ç–æ—á–Ω—ñ—Å—Ç—é 1e-7.</p>`;
                    jacobiSection += formatVector(result.jacobi.solution, "–§—ñ–Ω–∞–ª—å–Ω–∏–π —Ä–æ–∑–≤'—è–∑–æ–∫ (x)");
                } else {
                    jacobiSection += `<div class="warning">${result.jacobi.message}</div>`;
                }
            }
            jacobiSection += `</div>`;
            output += jacobiSection;
            
            // --- Section 2: Newton-Raphson ---
            let newtonSection = `<div class="result-section"><h3>2) –í–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞ —á–µ—Ä–µ–∑ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è</h3>`;
            newtonSection += `<div class="theory-block"><strong>–¢–µ–æ—Ä—ñ—è:</strong> –í–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞ –º–∞—Ç—Ä–∏—Ü—ñ A —î –∫–æ—Ä–µ–Ω—è–º–∏ —ó—ó —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è–Ω–Ω—è, —è–∫–µ –æ—Ç—Ä–∏–º—É—î—Ç—å—Å—è –∑ —É–º–æ–≤–∏ det(A - ŒªI) = 0, –¥–µ Œª - –≤–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ. –î–ª—è –º–∞—Ç—Ä–∏—Ü—ñ n x n —Ü–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è —î –ø–æ–ª—ñ–Ω–æ–º–æ–º n-–≥–æ —Å—Ç—É–ø–µ–Ω—è –≤—ñ–¥–Ω–æ—Å–Ω–æ Œª. –ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞-–†–∞—Ñ—Å–æ–Ω–∞ ‚Äî —Ü–µ –ø–æ—Ç—É–∂–Ω–∏–π —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–∏–π —á–∏—Å–µ–ª—å–Ω–∏–π –º–µ—Ç–æ–¥ –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –∫–æ—Ä–µ–Ω—ñ–≤ (–Ω—É–ª—ñ–≤) —Ñ—É–Ω–∫—Ü—ñ—ó p(Œª)=0. –ü–æ—á–∏–Ω–∞—é—á–∏ –∑ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è Œª‚ÇÄ, –∫–æ–∂–Ω–µ –Ω–∞—Å—Ç—É–ø–Ω–µ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è Œª_(k+1) –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è —è–∫ —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Ç–∏–Ω—É –¥–æ—Ç–∏—á–Ω–æ—ó –¥–æ –≥—Ä–∞—Ñ—ñ–∫–∞ —Ñ—É–Ω–∫—Ü—ñ—ó –≤ —Ç–æ—á—Ü—ñ Œª_k –∑ –≤—ñ—Å—Å—é –∞–±—Å—Ü–∏—Å. –ú–µ—Ç–æ–¥ –º–∞—î —à–≤–∏–¥–∫—É (–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω—É) –∑–±—ñ–∂–Ω—ñ—Å—Ç—å, —è–∫—â–æ –ø–æ—á–∞—Ç–∫–æ–≤–µ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è —î –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –±–ª–∏–∑—å–∫–∏–º –¥–æ –∫–æ—Ä–µ–Ω—è.</div>`;
            newtonSection += `<div class="formula-block">1. –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è: det(A - ŒªI) = 0
   –î–ª—è –º–∞—Ç—Ä–∏—Ü—ñ 3x3: p(Œª) = -Œª¬≥ + tr(A)¬∑Œª¬≤ - (M‚ÇÅ‚ÇÅ+M‚ÇÇ‚ÇÇ+M‚ÇÉ‚ÇÉ)¬∑Œª + det(A)

2. –ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞-–†–∞—Ñ—Å–æ–Ω–∞ –¥–ª—è –ø–æ—à—É–∫—É –∫–æ—Ä–µ–Ω—è p(Œª):
               p(Œª_k)
   Œª_(k+1) = Œª_k - ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
               p'(Œª_k)</div>`;
            if (typeof result.eigenNewton === 'string') { newtonSection += `<p>${result.eigenNewton}</p>`; }
            else if (result.eigenNewton.error) { newtonSection += `<div class="warning">${result.eigenNewton.error}</div>`; }
            else if (result.eigenNewton) {
                newtonSection += `<p><strong>–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è (–¥–ª—è –º–∞—Ç—Ä–∏—Ü—ñ A'):</strong><br>${result.eigenNewton.polynomial}</p>`;
                newtonSection += `<div class="vector-display"><strong>–ó–Ω–∞–π–¥–µ–Ω—ñ –≤–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞ (–∫–æ—Ä–µ–Ω—ñ —Ä—ñ–≤–Ω—è–Ω–Ω—è):</strong>\n`;
                result.eigenNewton.eigenvalues.forEach((val, i) => { newtonSection += `Œª_${i + 1} = ${val.toFixed(7)}\n`; });
                newtonSection += `</div>`;
            }
            newtonSection += `</div>`;
            output += newtonSection;
            
            // --- Section 3: Power Iteration ---
            let powerSection = `<div class="result-section"><h3>3) –í–ª–∞—Å–Ω—ñ –≤–µ–∫—Ç–æ—Ä–∏ –º–µ—Ç–æ–¥–æ–º —Å—Ç–µ–ø–µ–Ω–µ–≤–∏—Ö —ñ—Ç–µ—Ä–∞—Ü—ñ–π</h3>`;
            powerSection += `<div class="theory-block"><strong>–¢–µ–æ—Ä—ñ—è:</strong> –¶–µ –∫–æ–º–ø–ª–µ–∫—Å —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–∏—Ö –º–µ—Ç–æ–¥—ñ–≤ –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –≤–ª–∞—Å–Ω–∏—Ö –ø–∞—Ä (–≤–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ —Ç–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π –π–æ–º—É –≤–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä) –º–∞—Ç—Ä–∏—Ü—ñ.
- <strong>–°—Ç–µ–ø–µ–Ω–µ–≤–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è</strong> –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∏–º –º–Ω–æ–∂–µ–Ω–Ω—è–º –º–∞—Ç—Ä–∏—Ü—ñ –Ω–∞ –¥–æ–≤—ñ–ª—å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—Ö–æ–¥–∏—Ç—å –≤–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ–º—É (–Ω–∞–π–±—ñ–ª—å—à–æ–º—É –∑–∞ –º–æ–¥—É–ª–µ–º) –≤–ª–∞—Å–Ω–æ–º—É —á–∏—Å–ª—É.
- <strong>–ó–≤–æ—Ä–æ—Ç–Ω–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è</strong> –∑–∞—Å—Ç–æ—Å–æ–≤—É—î —Ç–æ–π –∂–µ –ø—Ä–∏–Ω—Ü–∏–ø –¥–æ A‚Åª¬π, —â–æ –¥–æ–∑–≤–æ–ª—è—î –∑–Ω–∞–π—Ç–∏ –≤–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –Ω–∞–π–º–µ–Ω—à–æ–º—É –∑–∞ –º–æ–¥—É–ª–µ–º –≤–ª–∞—Å–Ω–æ–º—É —á–∏—Å–ª—É A.
- <strong>–ú–µ—Ç–æ–¥ –∑—ñ –∑—Å—É–≤–æ–º</strong> –¥–æ–∑–≤–æ–ª—è—î –∑–Ω–∞—Ö–æ–¥–∏—Ç–∏ –≤–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞, –±–ª–∏–∑—å–∫—ñ –¥–æ –∑–∞–¥–∞–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è (–∑—Å—É–≤—É 's'). –ó–∞—Å—Ç–æ—Å–æ–≤—É—é—á–∏ –∑–≤–æ—Ä–æ—Ç–Ω—É —ñ—Ç–µ—Ä–∞—Ü—ñ—é –¥–æ –º–∞—Ç—Ä–∏—Ü—ñ (A - sI), –º–∏ –∑–Ω–∞—Ö–æ–¥–∏–º–æ –≤–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ, –Ω–∞–π–±–ª–∏–∂—á–µ –¥–æ 's'.</div>`;
            powerSection += `<div class="formula-block">1. –°—Ç–µ–ø–µ–Ω–µ–≤–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è:        v_new = A¬∑v_old / ||A¬∑v_old||
2. –ó–≤–æ—Ä–æ—Ç–Ω–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è:         v_new = A‚Åª¬π¬∑v_old / ||A‚Åª¬π¬∑v_old||
3. –Ü—Ç–µ—Ä–∞—Ü—ñ—è –∑—ñ –∑—Å—É–≤–æ–º 's':    v_new = (A-sI)‚Åª¬π¬∑v_old / ||...||</div>`;
             if (typeof result.eigenPower === 'string') { powerSection += `<p>${result.eigenPower}</p>`; }
            else if (result.eigenPower.error) { powerSection += `<div class="warning">${result.eigenPower.error}</div>`; }
            else if (result.eigenPower) {
                for (let i = 0; i < result.eigenPower.eigenvalues.length; i++) {
                    powerSection += formatVector([result.eigenPower.eigenvalues[i]], `–í–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ Œª_${i + 1}`);
                    powerSection += formatVector(result.eigenPower.eigenvectors[i], `–í—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π –≤–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä v_${i + 1}`);
                }
            }
            powerSection += `</div>`;
            output += powerSection;

            // --- Section 4: Low-Rank ---
            let svdSection = `<div class="result-section"><h3>4) –ù–∏–∑—å–∫–æ—Ä–∞–Ω–≥–æ–≤–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è (k=${result.lowRank.rank})</h3>`;
            svdSection += `<div class="theory-block"><strong>–¢–µ–æ—Ä—ñ—è:</strong> –°–∏–Ω–≥—É–ª—è—Ä–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ (SVD) ‚Äî —Ü–µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞ –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü—ñ—è –º–∞—Ç—Ä–∏—Ü—ñ, —è–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –±—É–¥—å-—è–∫—É –º–∞—Ç—Ä–∏—Ü—é A —É –≤–∏–≥–ª—è–¥—ñ –¥–æ–±—É—Ç–∫—É —Ç—Ä—å–æ—Ö –º–∞—Ç—Ä–∏—Ü—å: A = UŒ£V·µÄ, –¥–µ U —Ç–∞ V —î –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∏–º–∏, –∞ Œ£ ‚Äî –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ—é. –î—ñ–∞–≥–æ–Ω–∞–ª—å–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ Œ£ –Ω–∞–∑–∏–≤–∞—é—Ç—å—Å—è —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏–º–∏ —á–∏—Å–ª–∞–º–∏ —ñ —î –Ω–µ–≤—ñ–¥'—î–º–Ω–∏–º–∏. –í–æ–Ω–∏ –ø–æ–∫–∞–∑—É—é—Ç—å "–≤–∞–∂–ª–∏–≤—ñ—Å—Ç—å" –∫–æ–∂–Ω–æ–≥–æ –ª—ñ–Ω—ñ–π–Ω–æ–≥–æ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è, —è–∫–µ –æ–ø–∏—Å—É—î –º–∞—Ç—Ä–∏—Ü—è. –ù–∏–∑—å–∫–æ—Ä–∞–Ω–≥–æ–≤–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è ‚Äî —Ü–µ –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è –º–∞—Ç—Ä–∏—Ü—ñ A –º–∞—Ç—Ä–∏—Ü–µ—é –º–µ–Ω—à–æ–≥–æ —Ä–∞–Ω–≥—É 'k'. –¶–µ –¥–æ—Å—è–≥–∞—î—Ç—å—Å—è —à–ª—è—Ö–æ–º –æ–±–Ω—É–ª–µ–Ω–Ω—è –≤—Å—ñ—Ö —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏—Ö —á–∏—Å–µ–ª, –∫—Ä—ñ–º k –Ω–∞–π–±—ñ–ª—å—à–∏—Ö, —â–æ —î –æ—Å–Ω–æ–≤–æ—é –¥–ª—è –º–µ—Ç–æ–¥—ñ–≤ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∑–æ–±—Ä–∞–∂–µ–Ω—å) —Ç–∞ –∑–º–µ–Ω—à–µ–Ω–Ω—è —à—É–º—É.</div>`;
            svdSection += `<div class="formula-block">1. –°–∏–Ω–≥—É–ª—è—Ä–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ (SVD): A = U ¬∑ Œ£ ¬∑ V·µÄ
2. –ù–∏–∑—å–∫–æ—Ä–∞–Ω–≥–æ–≤–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è: A_k = U_k ¬∑ Œ£_k ¬∑ V_k·µÄ</div>`;
            if (typeof result.lowRank === 'string') { svdSection += `<p>${result.lowRank}</p>`; }
            else { svdSection += formatMatrix(result.lowRank.matrix, `–ê–ø—Ä–æ–∫—Å–∏–º–æ–≤–∞–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è A_k (—Ä–∞–Ω–≥ k=${result.lowRank.rank})`); }
            svdSection += `</div>`;
            output += svdSection;
            
            // --- Section 5: Condition Numbers ---
            let condSection = `<div class="result-section"><h3>5) –ß–∏—Å–ª–æ –æ–±—É–º–æ–≤–ª–µ–Ω–æ—Å—Ç—ñ</h3>`;
            condSection += `<div class="theory-block"><strong>–¢–µ–æ—Ä—ñ—è:</strong> –ß–∏—Å–ª–æ –æ–±—É–º–æ–≤–ª–µ–Ω–æ—Å—Ç—ñ Œ∫(A) —î –∫–ª—é—á–æ–≤–æ—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–æ—é –º–∞—Ç—Ä–∏—Ü—ñ –≤ —á–∏—Å–µ–ª—å–Ω–∏—Ö –º–µ—Ç–æ–¥–∞—Ö. –í–æ–Ω–æ –≤–∏–º—ñ—Ä—é—î, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ —Å–∏–ª—å–Ω–æ –∑–º—ñ–Ω–∏—Ç—å—Å—è —Ä–æ–∑–≤'—è–∑–æ–∫ —Å–∏—Å—Ç–µ–º–∏ Ax=b –ø—Ä–∏ –Ω–µ–≤–µ–ª–∏–∫–∏—Ö –∑–º—ñ–Ω–∞—Ö —É –≤—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö (–º–∞—Ç—Ä–∏—Ü—ñ A –∞–±–æ –≤–µ–∫—Ç–æ—Ä—ñ b).
- <strong>–í–µ–ª–∏–∫–µ –∑–Ω–∞—á–µ–Ω–Ω—è Œ∫(A) (>>1)</strong> —Å–≤—ñ–¥—á–∏—Ç—å, —â–æ —Å–∏—Å—Ç–µ–º–∞ —î "–ø–æ–≥–∞–Ω–æ –æ–±—É–º–æ–≤–ª–µ–Ω–æ—é". –ù–∞–≤—ñ—Ç—å –Ω–µ–∑–Ω–∞—á–Ω—ñ –ø–æ—Ö–∏–±–∫–∏ —É –≤—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö –º–æ–∂—É—Ç—å –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –∑–Ω–∞—á–Ω–∏—Ö –ø–æ—Ö–∏–±–æ–∫ —É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ.
- <strong>–ú–∞–ª–µ –∑–Ω–∞—á–µ–Ω–Ω—è Œ∫(A) (–±–ª–∏–∑—å–∫–µ –¥–æ 1)</strong> —Å–≤—ñ–¥—á–∏—Ç—å –ø—Ä–æ "–¥–æ–±—Ä–µ –æ–±—É–º–æ–≤–ª–µ–Ω—É" —Å–∏—Å—Ç–µ–º—É, —Å—Ç—ñ–π–∫—É –¥–æ –º–∞–ª–∏—Ö –∑–±—É—Ä–µ–Ω—å.</div>`;
            condSection += `<div class="formula-block">–ó–∞–≥–∞–ª—å–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è:       Œ∫(A) = ||A|| ¬∑ ||A‚Åª¬π||

1. –ù–æ—Ä–º–∞-1 (—Å—Ç–æ–≤–ø—Ü–µ–≤–∞):      ||A||‚ÇÅ = max_j Œ£_i |a_ij|
2. –ù–æ—Ä–º–∞-‚àû (—Ä—è–¥–∫–æ–≤–∞):        ||A||_‚àû = max_i Œ£_j |a_ij|
3. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞ –Ω–æ—Ä–º–∞ (2):    ||A||‚ÇÇ = œÉ_max(A)  =>  Œ∫‚ÇÇ(A) = œÉ_max / œÉ_min
4. –ù–æ—Ä–º–∞ –§—Ä–æ–±–µ–Ω—ñ—É—Å–∞:        ||A||_F = sqrt( Œ£_i Œ£_j |a_ij|¬≤ )</div>`;
            if (typeof result.conditionNumbers === 'string') { condSection += `<p>${result.conditionNumbers}</p>`; }
            else {
                condSection += `<div class="vector-display">1. –ó–∞ –Ω–æ—Ä–º–æ—é 1 (—Å—Ç–æ–≤–ø—Ü–µ–≤–∞):      Œ∫‚ÇÅ(A) = ${result.conditionNumbers.cond1.toFixed(4)}
2. –ó–∞ –Ω–æ—Ä–º–æ—é ‚àû (—Ä—è–¥–∫–æ–≤–∞):        Œ∫_inf(A) = ${result.conditionNumbers.condInf.toFixed(4)}
3. –ó–∞ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ—é –Ω–æ—Ä–º–æ—é (2):    Œ∫‚ÇÇ(A) = ${result.conditionNumbers.cond2.toFixed(4)}
4. –ó–∞ –Ω–æ—Ä–º–æ—é –§—Ä–æ–±–µ–Ω—ñ—É—Å–∞:         Œ∫_F(A) = ${result.conditionNumbers.condFrobenius.toFixed(4)}
</div>`;
            }
            condSection += `</div>`;
            output += condSection;
            
            resultsDiv.innerHTML = output;
        }

        window.onload = createMatrixInputs;
    </script>
</body>

</html>