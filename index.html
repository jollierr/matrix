<!DOCTYPE html>
<html lang="uk">

<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>–ú–∞—Ç—Ä–∏—á–Ω–∏–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä: –ü–æ–≤–Ω–∏–π –†–æ–∑–≤'—è–∑–æ–∫ –∑ –§–æ—Ä–º—É–ª–∞–º–∏</title>
      <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/8801/8801287.png" type="image/x-icon" />
      <style>
            body {
                  font-family: Arial, sans-serif;
                  margin: 20px;
                  background-color: #f4f4f9;
            }

            .container {
                  max-width: 1100px;
                  margin: auto;
                  background: white;
                  padding: 20px;
                  border-radius: 8px;
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            h1 {
                  color: #333;
                  text-align: center;
            }

            .controls-grid {
                  display: grid;
                  grid-template-columns: 1fr 1fr 1fr;
                  gap: 20px;
                  margin-bottom: 15px;
                  align-items: end;
            }

            label {
                  display: block;
                  margin-bottom: 5px;
                  font-weight: bold;
            }

            input[type="number"],
            input[type="text"] {
                  padding: 8px;
                  border: 1px solid #ccc;
                  border-radius: 4px;
                  width: 100%;
                  box-sizing: border-box;
            }

            button {
                  background-color: #007bff;
                  color: white;
                  padding: 10px 15px;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 16px;
                  transition: background-color 0.3s;
                  width: 100%;
            }

            button:hover {
                  background-color: #0056b3;
            }

            #matrixInput {
                  display: grid;
                  gap: 10px;
                  margin-top: 15px;
            }

            .matrix-row {
                  display: flex;
                  gap: 10px;
            }

            .matrix-row input {
                  text-align: center;
                  flex: 1;
            }

            #results {
                  margin-top: 20px;
                  padding: 15px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  background-color: #e9ecef;
                  white-space: pre-wrap;
                  font-family: "Courier New", Courier, monospace;
                  overflow-x: auto;
            }

            .error-message {
                  color: red;
                  font-weight: bold;
            }
      </style>
</head>

<body>
      <div class="container">
            <h1>–ú–∞—Ç—Ä–∏—á–Ω–∏–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä üìä</h1>
            <div class="controls-grid">
                  <div>
                        <label for="rowsSize">–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤ (M):</label>
                        <input type="number" id="rowsSize" min="1" max="10" value="3" onchange="createMatrixInputs()">
                  </div>
                  <div>
                        <label for="colsSize">–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Å—Ç–æ–≤–ø—Ü—ñ–≤ (N):</label>
                        <input type="number" id="colsSize" min="1" max="10" value="3" onchange="createMatrixInputs()">
                  </div>
                  <div>
                        <label for="rankK">–†–∞–Ω–≥ –¥–ª—è –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è (k):</label>
                        <input type="number" id="rankK" min="1" value="2" onchange="updateRankKMax()">
                  </div>
            </div>
            <div>
                  <label>–í–≤–µ–¥—ñ—Ç—å –µ–ª–µ–º–µ–Ω—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ñ A:</label>
                  <div id="matrixInput"></div>
            </div>
            <div id="vectorBContainer" style="margin-top: 15px;">
                  <label>–í–≤–µ–¥—ñ—Ç—å –≤–µ–∫—Ç–æ—Ä b (–¥–ª—è –º–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ):</label>
                  <div id="vectorBInput"></div>
            </div>
            <button onclick="calculate()" style="margin-top: 15px;">–û–±—á–∏—Å–ª–∏—Ç–∏</button>
            <div id="results">–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑'—è–≤–ª—è—Ç—å—Å—è —Ç—É—Ç.</div>
      </div>

      <script>
            // --- –í–•–Ü–î–ù–Ü –î–ê–ù–Ü –ó–ê –ó–ê–ú–û–í–ß–£–í–ê–ù–ù–Ø–ú ---
            const defaultMatrixValues = [[2, 0, 18], [11, 0.5, -3], [1, 18, -3]];
            const defaultVectorBValues = [-3, -5, -10];
            const EPSILON = 1e-10;

            // --- UI FUNCTIONS ---
            function updateRankKMax() { const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value), rankKInput = document.getElementById('rankK'); if (!isNaN(M) && !isNaN(N)) { rankKInput.max = Math.min(M, N); } }
            function createMatrixInputs() {
                  const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value);
                  const matrixContainer = document.getElementById('matrixInput'), vectorBContainer = document.getElementById('vectorBContainer'), vectorBInput = document.getElementById('vectorBInput');
                  if (M < 1 || M > 10 || isNaN(M) || N < 1 || N > 10 || isNaN(N)) { matrixContainer.innerHTML = `<span class="error-message">–†–æ–∑–º—ñ—Ä –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –≤—ñ–¥ 1 –¥–æ 10.</span>`; vectorBContainer.style.display = 'none'; return; }
                  matrixContainer.innerHTML = '';
                  for (let i = 0; i < M; i++) {
                        const rowDiv = document.createElement('div');
                        rowDiv.className = 'matrix-row';
                        for (let j = 0; j < N; j++) {
                              const input = document.createElement('input');
                              input.type = 'text'; input.id = `m-${i}-${j}`;
                              if (M === 3 && N === 3 && defaultMatrixValues[i]?.[j] !== undefined) input.value = defaultMatrixValues[i][j];
                              else if (M === N) input.value = (i === j) ? '1' : '0';
                              else input.value = '0';
                              rowDiv.appendChild(input);
                        }
                        matrixContainer.appendChild(rowDiv);
                  }
                  if (M === N) {
                        vectorBContainer.style.display = 'block'; vectorBInput.innerHTML = '';
                        const rowDiv = document.createElement('div'); rowDiv.className = 'matrix-row';
                        for (let i = 0; i < M; i++) {
                              const input = document.createElement('input');
                              input.type = 'text'; input.id = `v-${i}`;
                              input.value = (M === 3 && defaultVectorBValues[i] !== undefined) ? defaultVectorBValues[i] : i + 1;
                              rowDiv.appendChild(input);
                        }
                        vectorBInput.appendChild(rowDiv);
                  } else { vectorBContainer.style.display = 'none'; vectorBInput.innerHTML = ''; }
                  updateRankKMax();
            }

            function calculate() {
                  const M = parseInt(document.getElementById('rowsSize').value), N = parseInt(document.getElementById('colsSize').value);
                  let matrix = [];
                  for (let i = 0; i < M; i++) {
                        let row = [];
                        for (let j = 0; j < N; j++) {
                              const value = parseFloat(document.getElementById(`m-${i}-${j}`).value.replace(',', '.'));
                              if (isNaN(value)) { document.getElementById('results').innerHTML = `<span class="error-message">–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —É –ø–æ–ª—ñ [${i + 1},${j + 1}].</span>`; return; }
                              row.push(value);
                        }
                        matrix.push(row);
                  }
                  let vectorB = null;
                  if (M === N) {
                        vectorB = [];
                        for (let i = 0; i < M; i++) {
                              const value = parseFloat(document.getElementById(`v-${i}`).value.replace(',', '.'));
                              if (isNaN(value)) { document.getElementById('results').innerHTML = `<span class="error-message">–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è —É –≤–µ–∫—Ç–æ—Ä—ñ b, –ø–æ–∑–∏—Ü—ñ—è [${i + 1}].</span>`; return; }
                              vectorB.push(value);
                        }
                  }

                  // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—É –º–∞—Ç—Ä–∏—Ü—é –¥–ª—è –≤–∏–≤–æ–¥—É
                  const originalMatrix = JSON.parse(JSON.stringify(matrix));

                  let rearrangementInfo = { wasRearranged: false };
                  let matrixForCalc = JSON.parse(JSON.stringify(matrix));
                  let vectorBForCalc = vectorB ? [...vectorB] : null;

                  if (M === N && !isDiagonallyDominant(matrixForCalc)) {
                        const permuteResult = tryPermuteForDominance(matrixForCalc, vectorBForCalc);
                        if (permuteResult.success) {
                              matrixForCalc = permuteResult.A;
                              vectorBForCalc = permuteResult.b;
                              rearrangementInfo = {
                                    wasRearranged: true,
                                    message: "–ü–û–ü–ï–†–ï–î–ñ–ï–ù–ù–Ø: –ü–æ—á–∞—Ç–∫–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü—è –Ω–µ —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é. –°–∏—Å—Ç–µ–º—É –±—É–ª–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–æ –¥–ª—è –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –∑–±—ñ–∂–Ω–æ—Å—Ç—ñ –º–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ.",
                              };
                        } else {
                              rearrangementInfo = {
                                    wasRearranged: false,
                                    message: "–ü–û–ü–ï–†–ï–î–ñ–ï–ù–ù–Ø: –ú–∞—Ç—Ä–∏—Ü—è –Ω–µ —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é, —ñ –Ω–µ –≤–¥–∞–ª–æ—Å—è –¥–æ—Å—è–≥—Ç–∏ —Ü—å–æ–≥–æ —à–ª—è—Ö–æ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ä—è–¥–∫—ñ–≤. –ó–±—ñ–∂–Ω—ñ—Å—Ç—å –Ω–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞."
                              };
                        }
                  }

                  const result = matrixOperations(matrixForCalc, vectorBForCalc);
                  displayResults(result, matrixForCalc, originalMatrix, rearrangementInfo);
            }

            // --- LINEAR ALGEBRA HELPERS ---
            function transpose(m) { if (!m || !m.length || !m[0].length) return []; return m[0].map((_, c) => m.map(r => r[c])); }
            function multiply(a, b) { return a.map(row => b[0].map((_, j) => row.reduce((sum, val, k) => sum + val * b[k][j], 0))); }
            function multiplyMatrixVector(A, v) { return A.map(r => r.reduce((s, x, j) => s + x * v[j], 0)); }
            function dot(v1, v2) { return v1.reduce((s, x, i) => s + x * v2[i], 0); }
            function norm(v) { return Math.sqrt(dot(v, v)); }
            function normalize(v) { const n = norm(v); return (n < EPSILON) ? v.map(() => 0) : v.map(x => x / n); }
            function subtractVectors(v1, v2) { return v1.map((x, i) => x - v2[i]); }
            function scalarMultiply(s, v) { return v.map(x => s * x); }
            function outerProduct(u, v) { return u.map(val_u => v.map(val_v => val_u * val_v)); }
            function subtractMatrices(A, B) { return A.map((row, i) => row.map((val, j) => val - B[i][j])); }
            function getNorms(m) { let n1 = 0, ni = 0, nF = 0; if (!m.length) return { n1, ni, nF }; for (let j = 0; j < m[0].length; j++) n1 = Math.max(n1, m.reduce((s, r) => s + Math.abs(r[j]), 0)); for (let i = 0; i < m.length; i++) { ni = Math.max(ni, m[i].reduce((s, v) => s + Math.abs(v), 0)); nF += m[i].reduce((s, v) => s + v * v, 0); } return { norm1: n1, normInf: ni, normFrobenius: Math.sqrt(nF) }; }
            function isDiagonallyDominant(A) { for (let i = 0; i < A.length; i++) { let diag = Math.abs(A[i][i]); let sum = 0; for (let j = 0; j < A.length; j++) { if (i !== j) sum += Math.abs(A[i][j]); } if (diag <= sum) return false; } return true; }

            // --- MAIN CALCULATION FUNCTIONS ---
            function tryPermuteForDominance(A, b) {
                  const n = A.length;
                  const permutation = new Array(n);
                  const used_rows = new Array(n).fill(false);

                  function findPermutation(k) {
                        if (k === n) { return true; }

                        for (let i = 0; i < n; i++) {
                              if (!used_rows[i]) {
                                    let off_diag_sum = 0;
                                    for (let j = 0; j < n; j++) {
                                          if (j !== k) {
                                                off_diag_sum += Math.abs(A[i][j]);
                                          }
                                    }
                                    if (Math.abs(A[i][k]) > off_diag_sum) {
                                          permutation[k] = i;
                                          used_rows[i] = true;
                                          if (findPermutation(k + 1)) {
                                                return true;
                                          }
                                          used_rows[i] = false; // Backtrack
                                    }
                              }
                        }
                        return false;
                  }

                  if (findPermutation(0)) {
                        const permutedA = new Array(n).fill(0).map(() => new Array(n));
                        const permutedB = new Array(n);
                        for (let i = 0; i < n; i++) {
                              permutedA[i] = [...A[permutation[i]]];
                              if (b) permutedB[i] = b[permutation[i]];
                        }
                        return { success: true, A: permutedA, b: permutedB, permutation };
                  }

                  return { success: false, A, b };
            }

            function jacobiMethod(A, b, maxIter = 100, tolerance = 1e-7) {
                  const n = A.length;
                  for (let i = 0; i < n; i++) { if (Math.abs(A[i][i]) < EPSILON) return { converged: false, message: `–ù—É–ª—å–æ–≤–∏–π –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç A[${i + 1},${i + 1}].` }; }
                  const dominance = isDiagonallyDominant(A);
                  let x = Array(n).fill(0);
                  const iterationHistory = [{ vector: [...x], calcs: Array(n).fill("–ü–æ—á–∞—Ç–∫–æ–≤–µ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è") }];
                  for (let iter = 0; iter < maxIter; iter++) {
                        const x_new = Array(n).fill(0);
                        const calcs = [];
                        for (let i = 0; i < n; i++) {
                              let sum = 0;
                              let formula = `( ${b[i]}`;
                              for (let j = 0; j < n; j++) {
                                    if (i !== j) {
                                          sum += A[i][j] * x[j];
                                          formula += ` - (${A[i][j]})*(${x[j].toFixed(4)})`;
                                    }
                              }
                              x_new[i] = (b[i] - sum) / A[i][i];
                              formula += ` ) / ${A[i][i]} = ${x_new[i].toFixed(7)}`;
                              calcs.push(formula);
                        }
                        iterationHistory.push({ vector: [...x_new], calcs: calcs });
                        if (norm(subtractVectors(x_new, x)) < tolerance) {
                              return { converged: true, solution: x_new, iterations: iter + 1, isDominant: dominance, residual: subtractVectors(b, multiplyMatrixVector(A, x_new)), iterationHistory };
                        }
                        x = x_new;
                  }
                  return { converged: false, message: `–ú–µ—Ç–æ–¥ –Ω–µ –∑—ñ–π—à–æ–≤—Å—è –∑–∞ ${maxIter} —ñ—Ç–µ—Ä–∞—Ü—ñ–π.`, isDominant: dominance, iterationHistory };
            }

            function findEigenvaluesNewton(A) {
                  if (A.length !== 3) return { error: "–ú–µ—Ç–æ–¥ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ —Ç—ñ–ª—å–∫–∏ –¥–ª—è –º–∞—Ç—Ä–∏—Ü—å 3x3." };

                  const tr = A[0][0] + A[1][1] + A[2][2];
                  const det = A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1]) - A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0]) + A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);
                  const m11 = A[1][1] * A[2][2] - A[1][2] * A[2][1];
                  const m22 = A[0][0] * A[2][2] - A[0][2] * A[2][0];
                  const m33 = A[0][0] * A[1][1] - A[0][1] * A[1][0];
                  const sum_minors = m11 + m22 + m33;

                  const p = (l) => -l * l * l + tr * l * l - sum_minors * l + det;
                  const p_prime = (l) => -3 * l * l + 2 * tr * l - sum_minors;

                  let lambda1 = tr / 3;
                  for (let i = 0; i < 50; i++) {
                        const p_val = p(lambda1);
                        const p_prime_val = p_prime(lambda1);
                        if (Math.abs(p_prime_val) < EPSILON) break;
                        const next_lambda = lambda1 - p_val / p_prime_val;
                        if (Math.abs(next_lambda - lambda1) < EPSILON) break;
                        lambda1 = next_lambda;
                  }

                  const a = -1, b = tr - lambda1, c = -sum_minors + lambda1 * b;
                  const discriminant = b * b - 4 * a * c;
                  if (discriminant < 0) return { error: "–ó–Ω–∞–π–¥–µ–Ω–æ –∫–æ–º–ø–ª–µ–∫—Å–Ω—ñ –∫–æ—Ä–µ–Ω—ñ, —è–∫—ñ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å—Å—è." };

                  const lambda2 = (-b + Math.sqrt(discriminant)) / (2 * a);
                  const lambda3 = (-b - Math.sqrt(discriminant)) / (2 * a);

                  const poly_str = `p(Œª) = -Œª¬≥ + (${tr.toFixed(3)})Œª¬≤ - (${sum_minors.toFixed(3)})Œª + (${det.toFixed(3)}) = 0`;
                  return { eigenvalues: [lambda1, lambda2, lambda3].sort((x, y) => y - x), polynomial: poly_str };
            }

            function powerIterationWithDeflation(A, numEigen) {
                  let currentA = A.map(row => [...row]);
                  const eigenvalues = [], eigenvectors = [];
                  for (let i = 0; i < numEigen; i++) {
                        let b_k = Array(A.length).fill(1);
                        let eigenvalue;
                        for (let iter = 0; iter < 100; iter++) {
                              b_k = normalize(multiplyMatrixVector(currentA, b_k));
                        }
                        eigenvalue = dot(b_k, multiplyMatrixVector(currentA, b_k));
                        eigenvalues.push(eigenvalue);
                        eigenvectors.push(b_k);
                        currentA = subtractMatrices(currentA, scalarMultiply(eigenvalue, outerProduct(b_k, b_k)));
                  }
                  return { eigenvalues, eigenvectors };
            }

            function jacobiEig(A) { const n = A.length; let D = A.map(r => [...r]); let V = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))); if (n <= 1) return { eigenvalues: n === 1 ? [D[0][0]] : [], eigenvectors: V }; for (let iter = 0; iter < 100; iter++) { let p = 0, q = 1, maxVal = Math.abs(D[0][1] || 0); for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) if (Math.abs(D[i][j]) > maxVal) { maxVal = Math.abs(D[i][j]); p = i; q = j; } if (maxVal < EPSILON) break; const d_pq = D[p][q], d_pp = D[p][p], d_qq = D[q][q]; const tau = (d_qq - d_pp) / (2 * d_pq); const t = Math.sign(tau || 1) / (Math.abs(tau) + Math.sqrt(1 + tau * tau)); const c = 1 / Math.sqrt(1 + t * t); const s = t * c; const Dp_orig = [...D[p]], Dq_orig = [...D[q]]; D[p][p] = d_pp - t * d_pq; D[q][q] = d_qq + t * d_pq; D[p][q] = D[q][p] = 0; for (let k = 0; k < n; k++) { if (k !== p && k !== q) { D[k][p] = D[p][k] = c * Dp_orig[k] - s * Dq_orig[k]; D[k][q] = D[q][k] = s * Dp_orig[k] + c * Dq_orig[k]; } } for (let k = 0; k < n; k++) { const V_kp = V[k][p], V_kq = V[k][q]; V[k][p] = c * V_kp - s * V_kq; V[k][q] = s * V_kp + c * V_kq; } } return { eigenvalues: D.map((r, i) => r[i]), eigenvectors: V }; }
            function calculateSVD(A) { const m = A.length, n = A[0].length; const At = transpose(A); const AtA = multiply(At, A); const { eigenvalues, eigenvectors: V_unordered } = jacobiEig(AtA); const eigPairs = eigenvalues.map((v, i) => ({ val: v, vec: V_unordered.map(r => r[i]) })).sort((a, b) => b.val - a.val); const singularValues = eigPairs.map(p => Math.sqrt(Math.max(0, p.val))); const V = transpose(eigPairs.map(p => p.vec)); let U_cols = []; for (let i = 0; i < n; i++) { if (singularValues[i] > EPSILON) { const u_col = multiplyMatrixVector(A, V.map(r => r[i])); U_cols.push(normalize(u_col)); } } const U = transpose(U_cols); const Sigma = Array(m).fill(0).map(() => Array(n).fill(0)); singularValues.forEach((s, i) => { if (i < m && i < n) Sigma[i][i] = s; }); return { U, Sigma, V, singularValues }; }
            function getInverseMatrix(A) { const n = A.length; if (n !== A[0].length) throw new Error("M is not square."); const aug = A.map((r, i) => [...r, ...Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))]); for (let i = 0; i < n; i++) { let max = i; for (let k = i + 1; k < n; k++) if (Math.abs(aug[k][i]) > Math.abs(aug[max][i])) max = k;[aug[i], aug[max]] = [aug[max], aug[i]]; if (Math.abs(aug[i][i]) < EPSILON) throw new Error("M is singular."); const p = aug[i][i]; for (let j = i; j < 2 * n; j++) aug[i][j] /= p; for (let k = 0; k < n; k++) if (k !== i) { const f = aug[k][i]; for (let j = i; j < 2 * n; j++) aug[k][j] -= f * aug[i][j]; } } return aug.map(r => r.slice(n)); }
            function calculateLowRank(U, Sigma, V, k) { const Uk = transpose(transpose(U).slice(0, k)); const Sk = Sigma.slice(0, k).map(r => r.slice(0, k)); const Vk = transpose(transpose(V).slice(0, k)); return multiply(multiply(Uk, Sk), transpose(Vk)); }

            function matrixOperations(matrix, b) {
                  const rows = matrix.length, cols = matrix[0].length, isSquare = rows === cols;
                  let results = {};

                  results.norms = getNorms(matrix);
                  results.svd = calculateSVD(matrix);

                  const { U, Sigma, V } = results.svd;
                  const k = parseInt(document.getElementById('rankK').value);
                  const maxRank = Math.min(rows, cols);
                  if (isNaN(k) || k < 1 || k > maxRank) {
                        results.lowRank = `–ù–µ–≤—ñ—Ä–Ω–∏–π —Ä–∞–Ω–≥ k. –û–±–µ—Ä—ñ—Ç—å k –≤—ñ–¥ 1 –¥–æ ${maxRank}.`;
                  } else {
                        results.lowRank = { matrix: calculateLowRank(U, Sigma, V, k), rank: k };
                  }

                  if (isSquare) {
                        results.eigenNewton = findEigenvaluesNewton(matrix);
                        results.eigenPower = powerIterationWithDeflation(matrix, rows);
                        try {
                              results.inverse = getInverseMatrix(matrix);
                              const normsA_inv = getNorms(results.inverse);
                              const sigmas = results.svd.singularValues;
                              const cond2 = (sigmas[sigmas.length - 1] < EPSILON) ? "‚àû" : (sigmas[0] / sigmas[sigmas.length - 1]);
                              results.conditionNumbers = {
                                    cond1: results.norms.norm1 * normsA_inv.norm1,
                                    condInf: results.norms.normInf * normsA_inv.normInf,
                                    condFrobenius: results.norms.normFrobenius * normsA_inv.normFrobenius,
                                    cond2
                              };
                        } catch (e) {
                              results.inverse = "–ú–∞—Ç—Ä–∏—Ü—è –≤–∏—Ä–æ–¥–∂–µ–Ω–∞.";
                              results.conditionNumbers = { cond1: "‚àû", condInf: "‚àû", condFrobenius: "‚àû", cond2: "‚àû" };
                        }
                        if (b) results.jacobi = jacobiMethod(matrix, b, 100, 1e-7);
                  } else {
                        results.inverse = "–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–Ω–∞.";
                        results.conditionNumbers = "–ú–∞—Ç—Ä–∏—Ü—è –Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–Ω–∞.";
                        results.jacobi = "–ú–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                        results.eigenNewton = "–ú–µ—Ç–æ–¥ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                        results.eigenPower = "–ú–µ—Ç–æ–¥ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏—Ö –º–∞—Ç—Ä–∏—Ü—å.";
                  }
                  return results;
            }

            // --- DISPLAY FUNCTIONS ---
            function formatMatrix(m, name, precision = 7) { if (!m || !m[0]) return ""; return `${name}:\n` + m.map(r => `| ${r.map(v => v.toFixed(precision).padStart(12, ' ')).join(' ')} |`).join('\n'); }
            function formatVector(v, name, precision = 7) { return `${name}:\n` + v.map(val => `| ${val.toFixed(precision).padStart(12, ' ')} |`).join('\n'); }

            function displayResults(result, matrixForCalc, originalMatrix, rearrangementInfo) {
                  const resultsDiv = document.getElementById('results');
                  let output = "--- –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –û–±—á–∏—Å–ª–µ–Ω—å ---\n";
                  const h_line = "\n" + "-".repeat(60) + "\n\n";

                  // 1. Jacobi Method
                  output += "1) –†–æ–∑–≤'—è–∑–∞—Ç–∏ —Å–∏—Å—Ç–µ–º—É —Ä—ñ–≤–Ω—è–Ω—å –º–µ—Ç–æ–¥–æ–º –Ø–∫–æ–±—ñ\n\n";

                  if (rearrangementInfo.message) {
                        output += rearrangementInfo.message + "\n\n";
                        output += formatMatrix(originalMatrix, '–ü–æ—á–∞—Ç–∫–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü—è (A)') + '\n\n';
                        output += formatMatrix(matrixForCalc, '–ú–∞—Ç—Ä–∏—Ü—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω—å (A\')') + '\n\n';
                  }

                  output += `–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –£–º–æ–≤–∏ –ó–±—ñ–∂–Ω–æ—Å—Ç—ñ (–î—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∞ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω—ñ—Å—Ç—å):\n–§–æ—Ä–º–∞–ª—å–Ω–æ: |a_ii| > Œ£_{j‚â†i} |a_ij| –¥–ª—è –≤—Å—ñ—Ö i.\n\n–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–ª—è –º–∞—Ç—Ä–∏—Ü—ñ, —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –≤ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è—Ö (A'):\n`;
                  if (matrixForCalc && matrixForCalc.length > 0) {
                        matrixForCalc.forEach((row, i) => {
                              const diag = Math.abs(row[i]);
                              let sum = 0;
                              let sumStr = [];
                              row.forEach((val, j) => {
                                    if (i !== j) {
                                          sum += Math.abs(val);
                                          sumStr.push(`|${val}|`);
                                    }
                              });
                              output += `–†—è–¥–æ–∫ ${i + 1}: |${row[i]}| > ${sumStr.join(' + ')}  =>  ${diag.toFixed(1)} > ${sum.toFixed(1)} -> ${diag > sum ? 'OK' : 'FAIL'}\n`;
                        });
                  }

                  if (typeof result.jacobi === 'string') { output += result.jacobi + "\n"; }
                  else if (result.jacobi) {
                        output += `\n–í–∏—Å–Ω–æ–≤–æ–∫: –ú–∞—Ç—Ä–∏—Ü—è ${result.jacobi.isDominant ? '—î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é. –ó–±—ñ–∂–Ω—ñ—Å—Ç—å –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞.' : '–ù–ï —î –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ—é. –ó–±—ñ–∂–Ω—ñ—Å—Ç—å –Ω–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞.'}\n`;
                        const jacobiFormula = `
–§–æ—Ä–º—É–ª–∞ –¥–ª—è —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—É:
              1   ‚éõ      n              ‚éû
x_i^(k+1) = ---- ‚éú b_i -  Œ£  a_ij * x_j^(k) ‚éü
            a_ii ‚éù     j=1, j‚â†i         ‚é†
`;
                        output += jacobiFormula;
                        if (result.jacobi.converged) {
                              output += `\n–ú–µ—Ç–æ–¥ –∑—ñ–π—à–æ–≤—Å—è –∑–∞ ${result.jacobi.iterations} —ñ—Ç–µ—Ä–∞—Ü—ñ–π –∑ —Ç–æ—á–Ω—ñ—Å—Ç—é 1e-7.\n\n`;
                              output += formatVector(result.jacobi.solution, "x (—Ñ—ñ–Ω–∞–ª—å–Ω–∏–π —Ä–æ–∑–≤'—è–∑–æ–∫)") + "\n";
                        } else {
                              output += "\n" + result.jacobi.message + "\n";
                        }
                        if (result.jacobi.iterationHistory) {
                              output += "\n--- –î–µ—Ç–∞–ª—å–Ω—ñ –Ü—Ç–µ—Ä–∞—Ü—ñ—ó –ú–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ ---\n";
                              result.jacobi.iterationHistory.forEach((hist, k) => {
                                    output += `\n--- –Ü—Ç–µ—Ä–∞—Ü—ñ—è ${k} ---\n`;
                                    output += formatVector(hist.vector, `x^(${k})`);
                                    if (k > 0) {
                                          output += "\n–†–æ–∑—Ä–∞—Ö—É–Ω–∫–∏:\n";
                                          hist.calcs.forEach((calc, i) => { output += ` x_${i + 1}^(${k}) = ${calc}\n`; });
                                    }
                              });
                        }
                  }
                  output += h_line;

                  // 2. Eigenvalues via Newton-Raphson
                  output += "2) –ó–Ω–∞–π—Ç–∏ –≤–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞ –º–∞—Ç—Ä–∏—Ü—ñ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è–Ω–Ω—è. –†—ñ–≤–Ω—è–Ω–Ω—è —Ä–æ–∑–≤‚Äô—è–∑–∞—Ç–∏ –º–µ—Ç–æ–¥–æ–º –ù—å—é—Ç–æ–Ω–∞-–†–∞—Ñ—Å–æ–Ω–∞\n\n";
                  const newtonFormulas = `–§–æ—Ä–º—É–ª–∏:
1. –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è: det(A - ŒªI) = 0
   –î–ª—è –º–∞—Ç—Ä–∏—Ü—ñ 3x3: -Œª¬≥ + tr(A)Œª¬≤ - (M‚ÇÅ‚ÇÅ+M‚ÇÇ‚ÇÇ+M‚ÇÉ‚ÇÉ)Œª + det(A) = 0
   –¥–µ tr(A) - —Å–ª—ñ–¥ –º–∞—Ç—Ä–∏—Ü—ñ, M_ii - –≥–æ–ª–æ–≤–Ω—ñ –º—ñ–Ω–æ—Ä–∏.
2. –ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞: Œª_(k+1) = Œª_k - p(Œª_k) / p'(Œª_k)\n\n`;
                  output += newtonFormulas;
                  if (typeof result.eigenNewton === 'string') { output += result.eigenNewton + "\n"; }
                  else if (result.eigenNewton.error) { output += result.eigenNewton.error + "\n"; }
                  else if (result.eigenNewton) {
                        output += "–í–∏–∑–Ω–∞—á–µ–Ω–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è:\n" + result.eigenNewton.polynomial + "\n\n";
                        output += "–ó–Ω–∞–π–¥–µ–Ω—ñ –≤–ª–∞—Å–Ω—ñ —á–∏—Å–ª–∞ (–∫–æ—Ä–µ–Ω—ñ —Ä—ñ–≤–Ω—è–Ω–Ω—è):\n";
                        result.eigenNewton.eigenvalues.forEach((val, i) => { output += `Œª_${i + 1} = ${val.toFixed(7)}\n`; });
                  }
                  output += h_line;

                  // 3. Eigenvectors via Power Iteration
                  output += "3) –ó–Ω–∞–π—Ç–∏ –≤–ª–∞—Å–Ω—ñ –≤–µ–∫—Ç–æ—Ä–∏ –º–∞—Ç—Ä–∏—Ü—ñ –º–µ—Ç–æ–¥–æ–º —Å—Ç–µ–ø–µ–Ω–µ–≤–∏—Ö —ñ—Ç–µ—Ä–∞—Ü—ñ–π –∑ –¥–µ—Ñ–ª—è—Ü—ñ—î—é\n\n";
                  const powerFormulas = `–§–æ—Ä–º—É–ª–∏:
1. –°—Ç–µ–ø–µ–Ω–µ–≤–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è (–∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –¥–æ–º—ñ–Ω–∞–Ω—Ç–Ω–æ–≥–æ –≤–ª–∞—Å–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ v):
   v^(k+1) = A * v^(k) / ||A * v^(k)||
2. –í–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ (—á–∞—Å—Ç–∫–∞ –†–µ–ª–µ—è): Œª = (v·µÄ * A * v) / (v·µÄ * v)
3. –î–µ—Ñ–ª—è—Ü—ñ—è –ì–æ—Ç–µ–ª—ñ–Ω–≥–∞: A_new = A_old - Œª * v * v·µÄ\n\n`;
                  output += powerFormulas;
                  if (typeof result.eigenPower === 'string') { output += result.eigenPower + "\n"; }
                  else if (result.eigenPower) {
                        for (let i = 0; i < result.eigenPower.eigenvalues.length; i++) {
                              output += `–í–ª–∞—Å–Ω–µ —á–∏—Å–ª–æ Œª_${i + 1}: ${result.eigenPower.eigenvalues[i].toFixed(7)}\n`;
                              output += formatVector(result.eigenPower.eigenvectors[i], `–í—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π –≤–ª–∞—Å–Ω–∏–π –≤–µ–∫—Ç–æ—Ä v_${i + 1}`) + "\n\n";
                        }
                  }
                  output += h_line;

                  // 4. Low-Rank Approximation
                  output += `4) –ó–Ω–∞–π—Ç–∏ lowRank –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—é –º–∞—Ç—Ä–∏—Ü—ñ –∑–∞ –ø–µ—Ä—à–∏–º–∏ –¥–≤–æ–º–∞ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∏–º–∏ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏ (k=${result.lowRank.rank})\n\n`;
                  const svdFormulas = `–§–æ—Ä–º—É–ª–∏:
1. –°–∏–Ω–≥—É–ª—è—Ä–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ (SVD): A = U * Œ£ * V·µÄ
2. –ù–∏–∑—å–∫–æ—Ä–∞–Ω–≥–æ–≤–∞ –∞–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è: A_k = U_k * Œ£_k * V_k·µÄ
   –¥–µ U_k, Œ£_k, V_k - –º–∞—Ç—Ä–∏—Ü—ñ –∑ –ø–µ—Ä—à–∏—Ö k —Å—Ç–æ–≤–ø—Ü—ñ–≤/—Ä—è–¥–∫—ñ–≤.\n\n`;
                  output += svdFormulas;
                  if (typeof result.lowRank === 'string') { output += result.lowRank + "\n"; }
                  else { output += formatMatrix(result.lowRank.matrix, `A_k (—Ä–∞–Ω–≥ k=${result.lowRank.rank})`) + "\n"; }
                  output += h_line;

                  // 5. Condition Numbers
                  output += "5) –ó–Ω–∞–π—Ç–∏ —á–∏—Å–ª–æ –æ–±—É–º–æ–≤–ª–µ–Ω–æ—Å—Ç—ñ —Å–∏—Å—Ç–µ–º–∏ –∑–∞ —á–æ—Ç–∏—Ä–º–∞ –Ω–æ—Ä–º–∞–º–∏\n\n";
                  const condFormulas = `–§–æ—Ä–º—É–ª–∏:
1. –ó–∞–≥–∞–ª—å–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è: Œ∫(A) = ||A|| * ||A‚Åª¬π||
2. –ù–æ—Ä–º–∞-1: ||A||‚ÇÅ = max_j Œ£_i |a_ij| (–º–∞–∫—Å. —Å—É–º–∞ –º–æ–¥—É–ª—ñ–≤ —Å—Ç–æ–≤–ø—Ü—ñ–≤)
3. –ù–æ—Ä–º–∞-‚àû: ||A||_‚àû = max_i Œ£_j |a_ij| (–º–∞–∫—Å. —Å—É–º–∞ –º–æ–¥—É–ª—ñ–≤ —Ä—è–¥–∫—ñ–≤)
4. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞ –Ω–æ—Ä–º–∞: ||A||‚ÇÇ = œÉ_max (–º–∞–∫—Å. —Å–∏–Ω–≥—É–ª—è—Ä–Ω–µ —á–∏—Å–ª–æ) => Œ∫‚ÇÇ(A) = œÉ_max / œÉ_min
5. –ù–æ—Ä–º–∞ –§—Ä–æ–±–µ–Ω—ñ—É—Å–∞: ||A||_F = sqrt( Œ£_i Œ£_j |a_ij|¬≤ )\n\n`;
                  output += condFormulas;
                  if (typeof result.conditionNumbers === 'string') { output += result.conditionNumbers + "\n"; }
                  else {
                        output += `1. –ù–æ—Ä–º–∞-1 (—Å—Ç–æ–≤–ø—Ü–µ–≤–∞):      Œ∫‚ÇÅ(A) = ${result.conditionNumbers.cond1.toFixed(4)}\n`;
                        output += `2. –ù–æ—Ä–º–∞-–Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ—Å—Ç—å (‚àû): Œ∫_inf(A) = ${result.conditionNumbers.condInf.toFixed(4)}\n`;
                        output += `3. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞ –Ω–æ—Ä–º–∞ (2):     Œ∫‚ÇÇ(A) = ${result.conditionNumbers.cond2.toFixed(4)}\n`;
                        output += `4. –ù–æ—Ä–º–∞ –§—Ä–æ–±–µ–Ω—ñ—É—Å–∞:         Œ∫_F(A) = ${result.conditionNumbers.condFrobenius.toFixed(4)}\n`;
                  }
                  output += h_line;

                  // Additional Info
                  output += "–î–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ –º–∞—Ç—Ä–∏—Ü—ñ\n\n";
                  output += "–û–±–µ—Ä–Ω–µ–Ω–∞ –ú–∞—Ç—Ä–∏—Ü—è (A‚Åª¬π):\n–û–±—á–∏—Å–ª—é—î—Ç—å—Å—è –º–µ—Ç–æ–¥–æ–º –ì–∞—É—Å–∞-–ñ–æ—Ä–¥–∞–Ω–∞ [A|I] -> [I|A‚Åª¬π]\n";
                  if (typeof result.inverse === 'string') output += result.inverse + "\n";
                  else output += formatMatrix(result.inverse, 'A‚Åª¬π') + "\n";

                  resultsDiv.innerText = output;
            }

            window.onload = createMatrixInputs;
      </script>
</body>

</html>